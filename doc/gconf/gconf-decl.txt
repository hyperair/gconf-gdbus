<MACRO>
<NAME>HAVE_ALLOCA</NAME>
#define HAVE_ALLOCA 1
</MACRO>
<MACRO>
<NAME>HAVE_ALLOCA_H</NAME>
#define HAVE_ALLOCA_H 1
</MACRO>
<MACRO>
<NAME>HAVE_MMAP</NAME>
#define HAVE_MMAP 1
</MACRO>
<MACRO>
<NAME>STDC_HEADERS</NAME>
#define STDC_HEADERS 1
</MACRO>
<MACRO>
<NAME>PACKAGE</NAME>
#define PACKAGE "GConf"
</MACRO>
<MACRO>
<NAME>VERSION</NAME>
#define VERSION "0.5"
</MACRO>
<MACRO>
<NAME>HAVE_GETTEXT</NAME>
#define HAVE_GETTEXT 1
</MACRO>
<MACRO>
<NAME>HAVE_LC_MESSAGES</NAME>
#define HAVE_LC_MESSAGES 1
</MACRO>
<MACRO>
<NAME>HAVE_STPCPY</NAME>
#define HAVE_STPCPY 1
</MACRO>
<MACRO>
<NAME>ENABLE_NLS</NAME>
#define ENABLE_NLS 1
</MACRO>
<MACRO>
<NAME>HAVE___ARGZ_COUNT</NAME>
#define HAVE___ARGZ_COUNT 1
</MACRO>
<MACRO>
<NAME>HAVE___ARGZ_NEXT</NAME>
#define HAVE___ARGZ_NEXT 1
</MACRO>
<MACRO>
<NAME>HAVE___ARGZ_STRINGIFY</NAME>
#define HAVE___ARGZ_STRINGIFY 1
</MACRO>
<MACRO>
<NAME>HAVE_DCGETTEXT</NAME>
#define HAVE_DCGETTEXT 1
</MACRO>
<MACRO>
<NAME>HAVE_GETCWD</NAME>
#define HAVE_GETCWD 1
</MACRO>
<MACRO>
<NAME>HAVE_GETPAGESIZE</NAME>
#define HAVE_GETPAGESIZE 1
</MACRO>
<MACRO>
<NAME>HAVE_MUNMAP</NAME>
#define HAVE_MUNMAP 1
</MACRO>
<MACRO>
<NAME>HAVE_NANOSLEEP</NAME>
#define HAVE_NANOSLEEP 1
</MACRO>
<MACRO>
<NAME>HAVE_PUTENV</NAME>
#define HAVE_PUTENV 1
</MACRO>
<MACRO>
<NAME>HAVE_SETENV</NAME>
#define HAVE_SETENV 1
</MACRO>
<MACRO>
<NAME>HAVE_SETLOCALE</NAME>
#define HAVE_SETLOCALE 1
</MACRO>
<MACRO>
<NAME>HAVE_STPCPY</NAME>
#define HAVE_STPCPY 1
</MACRO>
<MACRO>
<NAME>HAVE_STRCASECMP</NAME>
#define HAVE_STRCASECMP 1
</MACRO>
<MACRO>
<NAME>HAVE_STRCHR</NAME>
#define HAVE_STRCHR 1
</MACRO>
<MACRO>
<NAME>HAVE_STRDUP</NAME>
#define HAVE_STRDUP 1
</MACRO>
<MACRO>
<NAME>HAVE_USLEEP</NAME>
#define HAVE_USLEEP 1
</MACRO>
<MACRO>
<NAME>HAVE_ARGZ_H</NAME>
#define HAVE_ARGZ_H 1
</MACRO>
<MACRO>
<NAME>HAVE_LIMITS_H</NAME>
#define HAVE_LIMITS_H 1
</MACRO>
<MACRO>
<NAME>HAVE_LOCALE_H</NAME>
#define HAVE_LOCALE_H 1
</MACRO>
<MACRO>
<NAME>HAVE_MALLOC_H</NAME>
#define HAVE_MALLOC_H 1
</MACRO>
<MACRO>
<NAME>HAVE_NL_TYPES_H</NAME>
#define HAVE_NL_TYPES_H 1
</MACRO>
<MACRO>
<NAME>HAVE_STRING_H</NAME>
#define HAVE_STRING_H 1
</MACRO>
<MACRO>
<NAME>HAVE_SYS_PARAM_H</NAME>
#define HAVE_SYS_PARAM_H 1
</MACRO>
<MACRO>
<NAME>HAVE_UNISTD_H</NAME>
#define HAVE_UNISTD_H 1
</MACRO>
<MACRO>
<NAME>PACKAGE</NAME>
#define PACKAGE "GConf"
</MACRO>
<MACRO>
<NAME>VERSION</NAME>
#define VERSION "0.5"
</MACRO>
<STRUCT>
<NAME>GThreadPool</NAME>
</STRUCT>
<STRUCT>
<NAME>Entry</NAME>
</STRUCT>
<FUNCTION>
<NAME>entry_new</NAME>
<RETURNS>Entry *</RETURNS>
const gchar  *relative_name
</FUNCTION>
<FUNCTION>
<NAME>entry_destroy</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_get_name</NAME>
<RETURNS>const gchar *</RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_set_node</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry,xmlNodePtr    node
</FUNCTION>
<FUNCTION>
<NAME>entry_get_node</NAME>
<RETURNS>xmlNodePtr  </RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_fill_from_node</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_sync_to_node</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_get_value</NAME>
<RETURNS>GConfValue *</RETURNS>
Entry        *entry,const gchar **locales,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>entry_set_value</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry,GConfValue   *value
</FUNCTION>
<FUNCTION>
<NAME>entry_unset_value</NAME>
<RETURNS>gboolean  </RETURNS>
Entry        *entry,const gchar  *locale
</FUNCTION>
<FUNCTION>
<NAME>entry_get_metainfo</NAME>
<RETURNS>GConfMetaInfo *</RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_set_mod_time</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry,GTime         mod_time
</FUNCTION>
<FUNCTION>
<NAME>entry_set_mod_user</NAME>
<RETURNS>void  </RETURNS>
Entry        *e,const gchar  *user
</FUNCTION>
<FUNCTION>
<NAME>entry_get_schema_name</NAME>
<RETURNS>const gchar *</RETURNS>
Entry        *e
</FUNCTION>
<FUNCTION>
<NAME>entry_set_schema_name</NAME>
<RETURNS>void  </RETURNS>
Entry        *e,const gchar  *name
</FUNCTION>
<FUNCTION>
<NAME>my_xmlSetProp</NAME>
<RETURNS>void  </RETURNS>
xmlNodePtr node,const gchar* name,const gchar* str
</FUNCTION>
<FUNCTION>
<NAME>my_xmlGetProp</NAME>
<RETURNS>char *</RETURNS>
xmlNodePtr node,const gchar* name
</FUNCTION>
<STRUCT>
<NAME>Dir</NAME>
</STRUCT>
<FUNCTION>
<NAME>dir_new</NAME>
<RETURNS>Dir *</RETURNS>
const gchar  *keyname,const gchar  *xml_root_dir,guint dir_mode,guint file_mode
</FUNCTION>
<FUNCTION>
<NAME>dir_load</NAME>
<RETURNS>Dir *</RETURNS>
const gchar  *key,const gchar  *xml_root_dir,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_destroy</NAME>
<RETURNS>void  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_clear_cache</NAME>
<RETURNS>void  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_ensure_exists</NAME>
<RETURNS>gboolean  </RETURNS>
Dir          *d,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_sync</NAME>
<RETURNS>gboolean  </RETURNS>
Dir          *d,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_get_name</NAME>
<RETURNS>const gchar *</RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_set_value</NAME>
<RETURNS>void  </RETURNS>
Dir          *d,const gchar  *relative_key,GConfValue   *value,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_get_value</NAME>
<RETURNS>GConfValue *</RETURNS>
Dir          *d,const gchar  *relative_key,const gchar **locales,gchar       **schema_name,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_get_metainfo</NAME>
<RETURNS>GConfMetaInfo *</RETURNS>
Dir          *d,const gchar  *relative_key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_unset_value</NAME>
<RETURNS>void  </RETURNS>
Dir          *d,const gchar  *relative_key,const gchar  *locale,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
Dir          *d,const gchar **locales,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_all_subdirs</NAME>
<RETURNS>GSList *</RETURNS>
Dir          *d,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_set_schema</NAME>
<RETURNS>void  </RETURNS>
Dir          *d,const gchar  *relative_key,const gchar  *schema_key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_get_last_access</NAME>
<RETURNS>GTime  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_sync_pending</NAME>
<RETURNS>gboolean  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_mark_deleted</NAME>
<RETURNS>void  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_is_deleted</NAME>
<RETURNS>gboolean  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>mode_t_to_mode</NAME>
<RETURNS>guint  </RETURNS>
mode_t orig
</FUNCTION>
<STRUCT>
<NAME>Cache</NAME>
</STRUCT>
<FUNCTION>
<NAME>cache_new</NAME>
<RETURNS>Cache *</RETURNS>
const gchar  *root_dir,guint dir_mode,guint file_mode
</FUNCTION>
<FUNCTION>
<NAME>cache_destroy</NAME>
<RETURNS>void  </RETURNS>
Cache        *cache
</FUNCTION>
<FUNCTION>
<NAME>cache_sync</NAME>
<RETURNS>gboolean  </RETURNS>
Cache        *cache,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>cache_clean</NAME>
<RETURNS>void  </RETURNS>
Cache        *cache,GTime         older_than
</FUNCTION>
<FUNCTION>
<NAME>cache_delete_dir</NAME>
<RETURNS>void  </RETURNS>
Cache        *cache,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>cache_lookup</NAME>
<RETURNS>Dir *</RETURNS>
Cache        *cache,const gchar  *key,gboolean create_if_missing,GError  **err
</FUNCTION>
<STRUCT>
<NAME>GConfBackendVTable</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfBackendVTable</NAME>
struct GConfBackendVTable {
  void                (* shutdown)        (GError** err);

  GConfSource*        (* resolve_address) (const gchar* address,
                                           GError** err);

  /* Thread locks. If the backend is thread-safe, then these
   * can be NULL. If per-source locks are needed, then these
   * calls should lock a mutex stored in the GConfSource.
   * If a per-backend lock is needed, then the calls can ignore
   * their source argument and lock the whole backend.
   */
  void                (* lock)            (GConfSource* source,
                                           GError** err);

  void                (* unlock)          (GConfSource* source,
                                           GError** err);

  /* Report whether a given key (and its subkeys) can be read/written.
   * Sources may not permit reading/writing from/to /foo but forbid
   * writing to /foo/bar; if a key can be read or written then its
   * subkeys may also be read/written.
   *
   * This field allows backends to be configured so that they only
   * store certain kinds of data in certain sections of the GConf
   * namespace.
   *
   * If these functions return an error, they MUST return FALSE as
   * well.
   */

  gboolean           (* readable)         (GConfSource* source,
                                           const gchar* key,
                                           GError** err);

  gboolean           (* writeable)        (GConfSource* source,
                                           const gchar* key,
                                           GError** err);
  
  /* schema_name filled if NULL or GCONF_VALUE_IGNORE_SUBSEQUENT returned.
     if schema_name is NULL, it isn't filled */
  GConfValue*         (* query_value)     (GConfSource* source, 
                                           const gchar* key,
                                           const gchar** locales,
                                           gchar** schema_name,
                                           GError** err);
  
  GConfMetaInfo*      (* query_metainfo)  (GConfSource* source,
                                           const gchar* key,
                                           GError** err);
  
  void                (* set_value)       (GConfSource* source, 
                                           const gchar* key, 
                                           GConfValue* value,
                                           GError** err);

  /* Returns list of GConfEntry */
  GSList*             (* all_entries)     (GConfSource* source,
                                           const gchar* dir,
                                           const gchar** locales,
                                           GError** err);

  /* Returns list of allocated strings, relative names */
  GSList*             (* all_subdirs)     (GConfSource* source,
                                           const gchar* dir,
                                           GError** err);

  void                (* unset_value)     (GConfSource* source,
                                           const gchar* key,
                                           const gchar* locale,
                                           GError** err);

  gboolean            (* dir_exists)      (GConfSource* source,
                                           const gchar* dir,
                                           GError** err);
        
  void                (* remove_dir)      (GConfSource* source,
                                           const gchar* dir,
                                           GError** err);
  
  void                (* set_schema)      (GConfSource* source,
                                           const gchar* key,
                                           const gchar* schema_key,
                                           GError** err);

  gboolean            (* sync_all)        (GConfSource* source,
                                           GError** err);

  void                (* destroy_source)  (GConfSource* source);

  /* This is basically used by the test suite */
  void                (* clear_cache)     (GConfSource* source);
};
</STRUCT>
<STRUCT>
<NAME>GConfBackend</NAME>
struct GConfBackend {
  const gchar* name;
  guint refcount;
  GConfBackendVTable* vtable;
  GModule* module;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_address_backend</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* address
</FUNCTION>
<FUNCTION>
<NAME>gconf_address_resource</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* address
</FUNCTION>
<FUNCTION>
<NAME>gconf_address_flags</NAME>
<RETURNS>gchar **</RETURNS>
const gchar* address
</FUNCTION>
<FUNCTION>
<NAME>gconf_backend_file</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* address
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_backend</NAME>
<RETURNS>GConfBackend *</RETURNS>
const gchar* address, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_backend_ref</NAME>
<RETURNS>void  </RETURNS>
GConfBackend* backend
</FUNCTION>
<FUNCTION>
<NAME>gconf_backend_unref</NAME>
<RETURNS>void  </RETURNS>
GConfBackend* backend
</FUNCTION>
<FUNCTION>
<NAME>gconf_backend_resolve_address</NAME>
<RETURNS>GConfSource *</RETURNS>
GConfBackend* backend,const gchar* address,GError** err
</FUNCTION>
<STRUCT>
<NAME>GConfEngine</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfEngine</NAME>
struct GConfEngine {
  gpointer dummy;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_engine_new</NAME>
<RETURNS>GConfEngine *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_new_from_address</NAME>
<RETURNS>GConfEngine *</RETURNS>
const gchar* address, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_unref</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_ref</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_new_local</NAME>
<RETURNS>GConfEngine *</RETURNS>
const gchar* address, GError** err
</FUNCTION>
<ENUM>
<NAME>GConfError</NAME>
typedef enum {
  GCONF_ERROR_SUCCESS = 0,
  GCONF_ERROR_FAILED = 1,        /* Something didn't work, don't know why, probably unrecoverable
                                    so there's no point having a more specific errno */

  GCONF_ERROR_NO_SERVER = 2,     /* Server can't be launched/contacted */
  GCONF_ERROR_NO_PERMISSION = 3, /* don't have permission for that */
  GCONF_ERROR_BAD_ADDRESS = 4,   /* Address couldn't be resolved */
  GCONF_ERROR_BAD_KEY = 5,       /* directory or key isn't valid (contains bad
                                    characters, or malformed slash arrangement) */
  GCONF_ERROR_PARSE_ERROR = 6,   /* Syntax error when parsing */
  GCONF_ERROR_CORRUPT = 7,       /* Fatal error parsing/loading information inside the backend */
  GCONF_ERROR_TYPE_MISMATCH = 8, /* Type requested doesn't match type found */
  GCONF_ERROR_IS_DIR = 9,        /* Requested key operation on a dir */
  GCONF_ERROR_IS_KEY = 10,       /* Requested dir operation on a key */
  GCONF_ERROR_OVERRIDDEN = 11,   /* Read-only source at front of path has set the value */
  GCONF_ERROR_OAF_ERROR = 12,    /* liboaf error */
  GCONF_ERROR_LOCAL_ENGINE = 13, /* Tried to use remote operations on a local engine */
  GCONF_ERROR_LOCK_FAILED = 14   /* Failed to get a lockfile */
} GConfError;
</ENUM>
<STRUCT>
<NAME>GError</NAME>
</STRUCT>
<STRUCT>
<NAME>GError</NAME>
struct GError {
  const gchar* str; /* combination of strerror of the num and additional
                       details; a complete error message. */
  GConfError num;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_error_new</NAME>
<RETURNS>GError *</RETURNS>
GConfError en, const gchar* format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_error_copy</NAME>
<RETURNS>GError *</RETURNS>
GError* err
</FUNCTION>
<FUNCTION>
<NAME>g_error_free</NAME>
<RETURNS>void  </RETURNS>
GError* err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_error</NAME>
<RETURNS>void  </RETURNS>
GError** err, GConfError en, const gchar* format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_clear_error</NAME>
<RETURNS>void  </RETURNS>
GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_compose_errors</NAME>
<RETURNS>GError *</RETURNS>
GError* err1, GError* err2
</FUNCTION>
<FUNCTION>
<NAME>gconf_strerror</NAME>
<RETURNS>const gchar *</RETURNS>
GConfError en
</FUNCTION>
<STRUCT>
<NAME>GConfListeners</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfListeners</NAME>
struct GConfListeners {
  gpointer dummy;
};
</STRUCT>
<USER_FUNCTION>
<NAME>GConfListenersCallback</NAME>
<RETURNS>void </RETURNS>
GConfListeners* listeners,
                                       const gchar* all_above_key,
                                       guint cnxn_id,
                                       gpointer listener_data,
                                       gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_new</NAME>
<RETURNS>GConfListeners *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_destroy</NAME>
<RETURNS>void  </RETURNS>
GConfListeners* listeners
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_add</NAME>
<RETURNS>guint  </RETURNS>
GConfListeners* listeners,const gchar* listen_point,gpointer listener_data,GFreeFunc destroy_notify
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_remove</NAME>
<RETURNS>void  </RETURNS>
GConfListeners* listeners,guint cnxn_id
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_notify</NAME>
<RETURNS>void  </RETURNS>
GConfListeners* listeners,const gchar* all_above,GConfListenersCallback callback,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_count</NAME>
<RETURNS>guint  </RETURNS>
GConfListeners* listeners
</FUNCTION>
<STRUCT>
<NAME>GConfSchema</NAME>
struct GConfSchema {
  GConfValueType type; /* Type of the described entry */
  gchar* locale;       /* Schema locale */
  gchar* owner;        /* Name of creating application */
  gchar* short_desc;   /* 40 char or less description, no newlines */
  gchar* long_desc;    /* could be a paragraph or so */
  GConfValue* default_value; /* Default value of the key */
};
</STRUCT>
<FUNCTION>
<NAME>gconf_schema_new</NAME>
<RETURNS>GConfSchema *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_destroy</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_copy</NAME>
<RETURNS>GConfSchema *</RETURNS>
GConfSchema* sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_type</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc, GConfValueType type
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_locale</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc, const gchar* locale
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_short_desc</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc, const gchar* desc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_long_desc</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc, const gchar* desc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_owner</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc, const gchar* owner
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_default_value</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc, GConfValue* val
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_default_value_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc, GConfValue* val
</FUNCTION>
<MACRO>
<NAME>gconf_schema_type</NAME>
#define       gconf_schema_type(x) (x->type)
</MACRO>
<MACRO>
<NAME>gconf_schema_locale</NAME>
#define       gconf_schema_locale(x)     ((const gchar*)(x)->locale)
</MACRO>
<MACRO>
<NAME>gconf_schema_short_desc</NAME>
#define       gconf_schema_short_desc(x) ((const gchar*)(x)->short_desc)
</MACRO>
<MACRO>
<NAME>gconf_schema_long_desc</NAME>
#define       gconf_schema_long_desc(x)  ((const gchar*)(x)->long_desc)
</MACRO>
<MACRO>
<NAME>gconf_schema_owner</NAME>
#define       gconf_schema_owner(x)      ((const gchar*)(x)->owner)
</MACRO>
<MACRO>
<NAME>gconf_schema_default_value</NAME>
#define       gconf_schema_default_value(x) ((x)->default_value)
</MACRO>
<STRUCT>
<NAME>GConfBackend</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfSource</NAME>
struct GConfSource {
  guint flags;
  gchar* address;
  GConfBackend* backend;
};
</STRUCT>
<ENUM>
<NAME>GConfSourceFlags</NAME>
typedef enum {
  /* These are an optimization to avoid calls to
   * the writeable/readable methods in the backend
   * vtable
   */
  GCONF_SOURCE_ALL_WRITEABLE = 1 << 0,
  GCONF_SOURCE_ALL_READABLE = 1 << 1,
  GCONF_SOURCE_NEVER_WRITEABLE = 1 << 2, 
  GCONF_SOURCE_ALL_FLAGS = ((1 << 0) | (1 << 1))
} GConfSourceFlags;
</ENUM>
<FUNCTION>
<NAME>gconf_resolve_address</NAME>
<RETURNS>GConfSource *</RETURNS>
const gchar* address,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_source_destroy</NAME>
<RETURNS>void  </RETURNS>
GConfSource* source
</FUNCTION>
<STRUCT>
<NAME>GConfSources</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfSources</NAME>
struct GConfSources {
  GList* sources;
  
};
</STRUCT>
<FUNCTION>
<NAME>gconf_sources_new_from_addresses</NAME>
<RETURNS>GConfSources *</RETURNS>
const gchar **addresses,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_new_from_source</NAME>
<RETURNS>GConfSources *</RETURNS>
GConfSource   *source
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_destroy</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_clear_cache</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_query_value</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfSources  *sources,const gchar   *key,const gchar  **locales,gboolean       use_schema_default,gboolean      *value_is_default,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_set_value</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources,const gchar   *key,GConfValue    *value,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_unset_value</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources,const gchar   *key,const gchar   *locale,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
GConfSources  *sources,const gchar   *dir,const gchar  **locales,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_all_dirs</NAME>
<RETURNS>GSList *</RETURNS>
GConfSources  *sources,const gchar   *dir,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_dir_exists</NAME>
<RETURNS>gboolean  </RETURNS>
GConfSources  *sources,const gchar   *dir,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_remove_dir</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources,const gchar   *dir,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources,const gchar   *key,const gchar   *schema_key,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_sync_all</NAME>
<RETURNS>gboolean  </RETURNS>
GConfSources  *sources,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_query_metainfo</NAME>
<RETURNS>GConfMetaInfo *</RETURNS>
GConfSources* sources,const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_query_default_value</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfSources* sources,const gchar* key,const gchar** locales,GError** err
</FUNCTION>
<ENUM>
<NAME>GConfValueType</NAME>
typedef enum {
  GCONF_VALUE_INVALID,
  GCONF_VALUE_STRING,
  GCONF_VALUE_INT,
  GCONF_VALUE_FLOAT,
  GCONF_VALUE_BOOL,
  GCONF_VALUE_SCHEMA,

  /* unfortunately these aren't really types; we want list_of_string,
     list_of_int, etc.  but it's just too complicated to implement.
     instead we'll complain in various places if you do something
     moronic like mix types in a list or treat pair<string,int> and
     pair<float,bool> as the same type. */
  GCONF_VALUE_LIST,
  GCONF_VALUE_PAIR
  
} GConfValueType;
</ENUM>
<MACRO>
<NAME>GCONF_VALUE_TYPE_VALID</NAME>
#define GCONF_VALUE_TYPE_VALID(x) (((x) > GCONF_VALUE_INVALID) && ((x) <= GCONF_VALUE_PAIR))
</MACRO>
<MACRO>
<NAME>GCONF_INTERNAL_VALUE_TYPE_VALID</NAME>
#define GCONF_INTERNAL_VALUE_TYPE_VALID(x) (((x) > GCONF_VALUE_INVALID) && ((x) <= GCONF_VALUE_PAIR))
</MACRO>
<STRUCT>
<NAME>GConfSchema</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfValue</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfValue</NAME>
struct GConfValue {
  GConfValueType type;
  union {
    gchar* string_data;
    gint int_data;
    gboolean bool_data;
    gdouble float_data;
    GConfSchema* schema_data;
    struct {
      GConfValueType type;
      GSList* list;
    } list_data;
    struct {
      GConfValue* car;
      GConfValue* cdr;
    } pair_data;
  } d;
};
</STRUCT>
<MACRO>
<NAME>gconf_value_string</NAME>
#define gconf_value_string(x)    ((const gchar*)((x)->d.string_data))
</MACRO>
<MACRO>
<NAME>gconf_value_int</NAME>
#define gconf_value_int(x)       ((x)->d.int_data)
</MACRO>
<MACRO>
<NAME>gconf_value_float</NAME>
#define gconf_value_float(x)     ((x)->d.float_data)
</MACRO>
<MACRO>
<NAME>gconf_value_list_type</NAME>
#define gconf_value_list_type(x) ((x)->d.list_data.type)
</MACRO>
<MACRO>
<NAME>gconf_value_list</NAME>
#define gconf_value_list(x)      ((x)->d.list_data.list)
</MACRO>
<MACRO>
<NAME>gconf_value_car</NAME>
#define gconf_value_car(x)       ((x)->d.pair_data.car)
</MACRO>
<MACRO>
<NAME>gconf_value_cdr</NAME>
#define gconf_value_cdr(x)       ((x)->d.pair_data.cdr)
</MACRO>
<MACRO>
<NAME>gconf_value_bool</NAME>
#define gconf_value_bool(x)      ((x)->d.bool_data)
</MACRO>
<MACRO>
<NAME>gconf_value_schema</NAME>
#define gconf_value_schema(x)    ((x)->d.schema_data)
</MACRO>
<FUNCTION>
<NAME>gconf_value_new</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType type
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_copy</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValue* src
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_destroy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_int</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,gint the_int
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_string</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,const gchar* the_str
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_float</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,gdouble the_float
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_bool</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,gboolean the_bool
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfSchema* sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_schema_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfSchema* sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_car</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValue* car
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_car_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValue* car
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_cdr</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValue* cdr
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_cdr_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValue* cdr
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_list_type</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValueType type
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_list_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GSList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_list</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GSList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_to_string</NAME>
<RETURNS>gchar *</RETURNS>
GConfValue* value
</FUNCTION>
<STRUCT>
<NAME>GConfMetaInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfMetaInfo</NAME>
struct GConfMetaInfo {
  gchar* schema;
  gchar* mod_user; /* user owning the daemon that made the last modification */
  GTime  mod_time; /* time of the modification */
};
</STRUCT>
<MACRO>
<NAME>gconf_meta_info_schema</NAME>
#define gconf_meta_info_schema(x)    ((const gchar*)(x)->schema)
</MACRO>
<MACRO>
<NAME>gconf_meta_info_mod_user</NAME>
#define gconf_meta_info_mod_user(x)  ((x)->mod_user)
</MACRO>
<MACRO>
<NAME>gconf_meta_info_mod_time</NAME>
#define gconf_meta_info_mod_time(x)  ((x)->mod_time)
</MACRO>
<FUNCTION>
<NAME>gconf_meta_info_new</NAME>
<RETURNS>GConfMetaInfo *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_meta_info_destroy</NAME>
<RETURNS>void  </RETURNS>
GConfMetaInfo* gcmi
</FUNCTION>
<FUNCTION>
<NAME>gconf_meta_info_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfMetaInfo* gcmi,const gchar* schema_name
</FUNCTION>
<FUNCTION>
<NAME>gconf_meta_info_set_mod_user</NAME>
<RETURNS>void  </RETURNS>
GConfMetaInfo* gcmi,const gchar* mod_user
</FUNCTION>
<FUNCTION>
<NAME>gconf_meta_info_set_mod_time</NAME>
<RETURNS>void  </RETURNS>
GConfMetaInfo* gcmi,GTime mod_time
</FUNCTION>
<STRUCT>
<NAME>GConfEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfEntry</NAME>
struct GConfEntry {
  gchar* key;
  GConfValue* value;
  gchar* schema_name;
  gboolean is_default;
};
</STRUCT>
<MACRO>
<NAME>gconf_entry_key</NAME>
#define     gconf_entry_key(x)      ((const gchar*)(x)->key)
</MACRO>
<MACRO>
<NAME>gconf_entry_value</NAME>
#define     gconf_entry_value(x)    ((x)->value)
</MACRO>
<MACRO>
<NAME>gconf_entry_schema_name</NAME>
#define     gconf_entry_schema_name(x) ((x)->schema_name)
</MACRO>
<MACRO>
<NAME>gconf_entry_is_default</NAME>
#define     gconf_entry_is_default(x)  ((x)->is_default)
</MACRO>
<FUNCTION>
<NAME>gconf_entry_new_nocopy</NAME>
<RETURNS>GConfEntry *</RETURNS>
gchar       *key,GConfValue  *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_destroy</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_steal_value</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEntry  *entry
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_set_value_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry,GConfValue  *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_set_schema_name</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry,const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_set_is_default</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry,gboolean     is_default
</FUNCTION>
<FUNCTION>
<NAME>gconf_is_initialized</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<USER_FUNCTION>
<NAME>GConfNotifyFunc</NAME>
<RETURNS>void </RETURNS>
GConfEngine* conf, guint cnxn_id, const gchar* key, GConfValue* value, gboolean is_default, gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gconf_notify_add</NAME>
<RETURNS>guint  </RETURNS>
GConfEngine      *conf,const gchar      *namespace_section,GConfNotifyFunc   func,gpointer          user_data,GError      **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_notify_remove</NAME>
<RETURNS>void  </RETURNS>
GConfEngine      *conf,guint             cnxn
</FUNCTION>
<FUNCTION>
<NAME>gconf_get</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_without_default</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_full</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,const gchar  *locale,gboolean      use_schema_default,gboolean     *value_is_default,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_with_locale</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,const gchar  *locale,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_default_from_schema</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine  *conf,const gchar  *key,GConfValue   *value,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_unset</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine  *conf,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_associate_schema</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine  *conf,const gchar  *key,const gchar  *schema_key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
GConfEngine  *conf,const gchar  *dir,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_all_dirs</NAME>
<RETURNS>GSList *</RETURNS>
GConfEngine  *conf,const gchar  *dir,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_suggest_sync</NAME>
<RETURNS>void  </RETURNS>
GConfEngine  *conf,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_dir_exists</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine  *conf,const gchar  *dir,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_valid_key</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *key,gchar       **why_invalid
</FUNCTION>
<FUNCTION>
<NAME>gconf_key_is_below</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *above,const gchar  *below
</FUNCTION>
<FUNCTION>
<NAME>gconf_concat_key_and_dir</NAME>
<RETURNS>gchar *</RETURNS>
const gchar  *dir,const gchar  *key
</FUNCTION>
<FUNCTION>
<NAME>gconf_unique_key</NAME>
<RETURNS>gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_float</NAME>
<RETURNS>gdouble  </RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_int</NAME>
<RETURNS>gint  </RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_string</NAME>
<RETURNS>gchar *</RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_bool</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_schema</NAME>
<RETURNS>GConfSchema *</RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_list</NAME>
<RETURNS>GSList *</RETURNS>
GConfEngine     *conf,const gchar     *key,GConfValueType   list_type,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_pair</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GConfValueType   car_type,GConfValueType   cdr_type,gpointer         car_retloc,gpointer         cdr_retloc,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_float</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,gdouble          val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_int</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,gint             val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_string</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,const gchar     *val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_bool</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,gboolean         val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_schema</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GConfSchema     *val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_list</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GConfValueType   list_type,GSList          *list,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_pair</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GConfValueType   car_type,GConfValueType   cdr_type,gconstpointer    address_of_car,gconstpointer    address_of_cdr,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_init</NAME>
<RETURNS>gboolean  </RETURNS>
int argc, char **argv, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_preinit</NAME>
<RETURNS>void  </RETURNS>
gpointer app, gpointer mod_info
</FUNCTION>
<FUNCTION>
<NAME>gconf_postinit</NAME>
<RETURNS>void  </RETURNS>
gpointer app, gpointer mod_info
</FUNCTION>
<STRUCT>
<NAME>GConfEnumStringPair</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfEnumStringPair</NAME>
struct GConfEnumStringPair {
  gint enum_value;
  const gchar* str;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_string_to_enum</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEnumStringPair  lookup_table[],const gchar         *str,gint                *enum_value_retloc
</FUNCTION>
<FUNCTION>
<NAME>gconf_enum_to_string</NAME>
<RETURNS>const gchar *</RETURNS>
GConfEnumStringPair  lookup_table[],gint                 enum_value
</FUNCTION>
<FUNCTION>
<NAME>gconf_clear_cache</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_synchronous_sync</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf, GError** err
</FUNCTION>
<STRUCT>
<NAME>GConfLocaleCache</NAME>
</STRUCT>
<FUNCTION>
<NAME>gconf_locale_cache_new</NAME>
<RETURNS>GConfLocaleCache *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_locale_cache_destroy</NAME>
<RETURNS>void  </RETURNS>
GConfLocaleCache* cache
</FUNCTION>
<FUNCTION>
<NAME>gconf_locale_cache_expire</NAME>
<RETURNS>void  </RETURNS>
GConfLocaleCache* cache,guint max_age_exclusive_in_seconds
</FUNCTION>
<STRUCT>
<NAME>GConfLocaleList</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfLocaleList</NAME>
struct GConfLocaleList {
  const gchar** list;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_locale_list_ref</NAME>
<RETURNS>void  </RETURNS>
GConfLocaleList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_locale_list_unref</NAME>
<RETURNS>void  </RETURNS>
GConfLocaleList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_locale_cache_get_list</NAME>
<RETURNS>GConfLocaleList *</RETURNS>
GConfLocaleCache* cache,const gchar* locale
</FUNCTION>
<FUNCTION>
<NAME>gconf_split_locale</NAME>
<RETURNS>gchar **</RETURNS>
const gchar* locale
</FUNCTION>
<MACRO>
<NAME>ORBIT_IDL_SERIAL</NAME>
#define ORBIT_IDL_SERIAL 9
</MACRO>
<MACRO>
<NAME>GConf_H</NAME>
#define GConf_H 1
</MACRO>
<ENUM>
<NAME>ConfigBasicValueType</NAME>
   typedef enum {
      BInvalidVal,
      BIntVal,
      BStringVal,
      BFloatVal,
      BBoolVal,
      BSchemaVal
   } ConfigBasicValueType;
</ENUM>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValueType_0</NAME>
#define TC_IMPL_TC_ConfigBasicValueType_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValueType_1</NAME>
#define TC_IMPL_TC_ConfigBasicValueType_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValueType_2</NAME>
#define TC_IMPL_TC_ConfigBasicValueType_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValueType_3</NAME>
#define TC_IMPL_TC_ConfigBasicValueType_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValueType_4</NAME>
#define TC_IMPL_TC_ConfigBasicValueType_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigBasicValueType</NAME>
#define TC_ConfigBasicValueType ((CORBA_TypeCode)&TC_ConfigBasicValueType_struct)
</MACRO>
<ENUM>
<NAME>ConfigValueType</NAME>
   typedef enum {
      InvalidVal,
      IntVal,
      StringVal,
      FloatVal,
      BoolVal,
      SchemaVal,
      ListVal,
      PairVal
   } ConfigValueType;
</ENUM>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValueType_0</NAME>
#define TC_IMPL_TC_ConfigValueType_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValueType_1</NAME>
#define TC_IMPL_TC_ConfigValueType_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValueType_2</NAME>
#define TC_IMPL_TC_ConfigValueType_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValueType_3</NAME>
#define TC_IMPL_TC_ConfigValueType_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValueType_4</NAME>
#define TC_IMPL_TC_ConfigValueType_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigValueType</NAME>
#define TC_ConfigValueType ((CORBA_TypeCode)&TC_ConfigValueType_struct)
</MACRO>
<TYPEDEF>
<NAME>ConfigSchema</NAME>
   typedef struct {
      ConfigValueType value_type;
      CORBA_char *locale;
      CORBA_char *short_desc;
      CORBA_char *long_desc;
      CORBA_char *owner;
      CORBA_char *encoded_default_value;
   } ConfigSchema;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigSchema_0</NAME>
#define TC_IMPL_TC_ConfigSchema_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigSchema_1</NAME>
#define TC_IMPL_TC_ConfigSchema_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigSchema_2</NAME>
#define TC_IMPL_TC_ConfigSchema_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigSchema_3</NAME>
#define TC_IMPL_TC_ConfigSchema_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigSchema_4</NAME>
#define TC_IMPL_TC_ConfigSchema_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigSchema</NAME>
#define TC_ConfigSchema ((CORBA_TypeCode)&TC_ConfigSchema_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigSchema__alloc</NAME>
<RETURNS>ConfigSchema  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigSchema__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<TYPEDEF>
<NAME>ConfigBasicValue</NAME>
   typedef struct {
      ConfigBasicValueType _d;
      union {
	 CORBA_long dummy;
	 CORBA_long int_value;
	 CORBA_char *string_value;
	 CORBA_float float_value;
	 CORBA_boolean bool_value;
	 ConfigSchema schema_value;
      } _u;
   } ConfigBasicValue;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValue_0</NAME>
#define TC_IMPL_TC_ConfigBasicValue_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValue_1</NAME>
#define TC_IMPL_TC_ConfigBasicValue_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValue_2</NAME>
#define TC_IMPL_TC_ConfigBasicValue_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValue_3</NAME>
#define TC_IMPL_TC_ConfigBasicValue_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValue_4</NAME>
#define TC_IMPL_TC_ConfigBasicValue_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigBasicValue</NAME>
#define TC_ConfigBasicValue ((CORBA_TypeCode)&TC_ConfigBasicValue_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigBasicValue__alloc</NAME>
<RETURNS>ConfigBasicValue  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigBasicValue__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_CORBA_sequence_ConfigBasicValue</NAME>
#define ORBIT_DECL_CORBA_sequence_ConfigBasicValue 1
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_0</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_0 'G'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_1</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_1 'C'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_2</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_2 'o'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_3</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_3 'n'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_4</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_4 'f'
</MACRO>
<TYPEDEF>
<NAME>CORBA_sequence_ConfigBasicValue</NAME>
   typedef struct {
      CORBA_unsigned_long _maximum,
       _length;
      ConfigBasicValue *_buffer;
      CORBA_boolean _release;
   } CORBA_sequence_ConfigBasicValue;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_0</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_1</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_2</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_3</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_4</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_4 'f'
</MACRO>
<MACRO>
<NAME>TC_CORBA_sequence_ConfigBasicValue</NAME>
#define TC_CORBA_sequence_ConfigBasicValue ((CORBA_TypeCode)&TC_CORBA_sequence_ConfigBasicValue_struct)
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_ConfigBasicValue__alloc</NAME>
<RETURNS>CORBA_sequence_ConfigBasicValue  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_ConfigBasicValue__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_ConfigBasicValue_allocbuf</NAME>
<RETURNS>ConfigBasicValue  *</RETURNS>
CORBA_unsigned_long len
</FUNCTION>
<TYPEDEF>
<NAME>BasicValueList</NAME>
   typedef CORBA_sequence_ConfigBasicValue BasicValueList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_BasicValueList_0</NAME>
#define TC_IMPL_TC_BasicValueList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_BasicValueList_1</NAME>
#define TC_IMPL_TC_BasicValueList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_BasicValueList_2</NAME>
#define TC_IMPL_TC_BasicValueList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_BasicValueList_3</NAME>
#define TC_IMPL_TC_BasicValueList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_BasicValueList_4</NAME>
#define TC_IMPL_TC_BasicValueList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_BasicValueList</NAME>
#define TC_BasicValueList ((CORBA_TypeCode)&TC_BasicValueList_struct)
</MACRO>
<FUNCTION>
<NAME>BasicValueList__alloc</NAME>
<RETURNS>BasicValueList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>BasicValueList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<TYPEDEF>
<NAME>ConfigList</NAME>
   typedef struct {
      BasicValueList seq;
      ConfigBasicValueType list_type;
   } ConfigList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigList_0</NAME>
#define TC_IMPL_TC_ConfigList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigList_1</NAME>
#define TC_IMPL_TC_ConfigList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigList_2</NAME>
#define TC_IMPL_TC_ConfigList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigList_3</NAME>
#define TC_IMPL_TC_ConfigList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigList_4</NAME>
#define TC_IMPL_TC_ConfigList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigList</NAME>
#define TC_ConfigList ((CORBA_TypeCode)&TC_ConfigList_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigList__alloc</NAME>
<RETURNS>ConfigList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<TYPEDEF>
<NAME>ConfigValue</NAME>
   typedef struct {
      ConfigValueType _d;
      union {
	 CORBA_long dummy;
	 CORBA_long int_value;
	 CORBA_char *string_value;
	 CORBA_float float_value;
	 CORBA_boolean bool_value;
	 ConfigSchema schema_value;
	 ConfigList list_value;
	 BasicValueList pair_value;
      } _u;
   } ConfigValue;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValue_0</NAME>
#define TC_IMPL_TC_ConfigValue_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValue_1</NAME>
#define TC_IMPL_TC_ConfigValue_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValue_2</NAME>
#define TC_IMPL_TC_ConfigValue_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValue_3</NAME>
#define TC_IMPL_TC_ConfigValue_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValue_4</NAME>
#define TC_IMPL_TC_ConfigValue_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigValue</NAME>
#define TC_ConfigValue ((CORBA_TypeCode)&TC_ConfigValue_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigValue__alloc</NAME>
<RETURNS>ConfigValue  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigValue__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_ConfigListener</NAME>
#define ORBIT_DECL_ConfigListener 1
</MACRO>
<MACRO>
<NAME>ConfigListener__free</NAME>
#define ConfigListener__free CORBA_Object__free
</MACRO>
<TYPEDEF>
<NAME>ConfigListener</NAME>
   typedef CORBA_Object ConfigListener;
</TYPEDEF>
<VARIABLE>
<NAME>ConfigListener__classid</NAME>
   extern CORBA_unsigned_long ConfigListener__classid;
</VARIABLE>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_0</NAME>
#define TC_IMPL_TC_ConfigListener_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_1</NAME>
#define TC_IMPL_TC_ConfigListener_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_2</NAME>
#define TC_IMPL_TC_ConfigListener_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_3</NAME>
#define TC_IMPL_TC_ConfigListener_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_4</NAME>
#define TC_IMPL_TC_ConfigListener_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigListener</NAME>
#define TC_ConfigListener ((CORBA_TypeCode)&TC_ConfigListener_struct)
</MACRO>
<ENUM>
<NAME>ConfigErrorType</NAME>
   typedef enum {
      ConfigFailed,
      ConfigNoPermission,
      ConfigBadAddress,
      ConfigBadKey,
      ConfigParseError,
      ConfigCorrupt,
      ConfigTypeMismatch,
      ConfigIsDir,
      ConfigIsKey,
      ConfigOverridden,
      ConfigLockFailed
   } ConfigErrorType;
</ENUM>
<MACRO>
<NAME>TC_IMPL_TC_ConfigErrorType_0</NAME>
#define TC_IMPL_TC_ConfigErrorType_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigErrorType_1</NAME>
#define TC_IMPL_TC_ConfigErrorType_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigErrorType_2</NAME>
#define TC_IMPL_TC_ConfigErrorType_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigErrorType_3</NAME>
#define TC_IMPL_TC_ConfigErrorType_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigErrorType_4</NAME>
#define TC_IMPL_TC_ConfigErrorType_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigErrorType</NAME>
#define TC_ConfigErrorType ((CORBA_TypeCode)&TC_ConfigErrorType_struct)
</MACRO>
<MACRO>
<NAME>ex_ConfigException</NAME>
#define ex_ConfigException "IDL:ConfigException:1.0"
</MACRO>
<TYPEDEF>
<NAME>ConfigException</NAME>
   typedef struct {
      ConfigErrorType err_no;
      CORBA_char *message;
   } ConfigException;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigException_0</NAME>
#define TC_IMPL_TC_ConfigException_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigException_1</NAME>
#define TC_IMPL_TC_ConfigException_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigException_2</NAME>
#define TC_IMPL_TC_ConfigException_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigException_3</NAME>
#define TC_IMPL_TC_ConfigException_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigException_4</NAME>
#define TC_IMPL_TC_ConfigException_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigException</NAME>
#define TC_ConfigException ((CORBA_TypeCode)&TC_ConfigException_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigException__alloc</NAME>
<RETURNS>ConfigException  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigException__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_ConfigServer</NAME>
#define ORBIT_DECL_ConfigServer 1
</MACRO>
<MACRO>
<NAME>ConfigServer__free</NAME>
#define ConfigServer__free CORBA_Object__free
</MACRO>
<TYPEDEF>
<NAME>ConfigServer</NAME>
   typedef CORBA_Object ConfigServer;
</TYPEDEF>
<VARIABLE>
<NAME>ConfigServer__classid</NAME>
   extern CORBA_unsigned_long ConfigServer__classid;
</VARIABLE>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_0</NAME>
#define TC_IMPL_TC_ConfigServer_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_1</NAME>
#define TC_IMPL_TC_ConfigServer_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_2</NAME>
#define TC_IMPL_TC_ConfigServer_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_3</NAME>
#define TC_IMPL_TC_ConfigServer_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_4</NAME>
#define TC_IMPL_TC_ConfigServer_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigServer</NAME>
#define TC_ConfigServer ((CORBA_TypeCode)&TC_ConfigServer_struct)
</MACRO>
<MACRO>
<NAME>ORBIT_DECL_CORBA_sequence_CORBA_string</NAME>
#define ORBIT_DECL_CORBA_sequence_CORBA_string 1
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_0</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_0 'G'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_1</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_1 'C'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_2</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_2 'o'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_3</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_3 'n'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_4</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_4 'f'
</MACRO>
<TYPEDEF>
<NAME>CORBA_sequence_CORBA_string</NAME>
   typedef struct {
      CORBA_unsigned_long _maximum,
       _length;
      CORBA_char **_buffer;
      CORBA_boolean _release;
   } CORBA_sequence_CORBA_string;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_0</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_1</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_2</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_3</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_4</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_4 'f'
</MACRO>
<MACRO>
<NAME>TC_CORBA_sequence_CORBA_string</NAME>
#define TC_CORBA_sequence_CORBA_string ((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_string_struct)
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_string__alloc</NAME>
<RETURNS>CORBA_sequence_CORBA_string  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_string__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_string_allocbuf</NAME>
<RETURNS>CORBA_char  **</RETURNS>
CORBA_unsigned_long len
</FUNCTION>
<TYPEDEF>
<NAME>ConfigServer_KeyList</NAME>
   typedef CORBA_sequence_CORBA_string ConfigServer_KeyList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_KeyList_0</NAME>
#define TC_IMPL_TC_ConfigServer_KeyList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_KeyList_1</NAME>
#define TC_IMPL_TC_ConfigServer_KeyList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_KeyList_2</NAME>
#define TC_IMPL_TC_ConfigServer_KeyList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_KeyList_3</NAME>
#define TC_IMPL_TC_ConfigServer_KeyList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_KeyList_4</NAME>
#define TC_IMPL_TC_ConfigServer_KeyList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigServer_KeyList</NAME>
#define TC_ConfigServer_KeyList ((CORBA_TypeCode)&TC_ConfigServer_KeyList_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigServer_KeyList__alloc</NAME>
<RETURNS>ConfigServer_KeyList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_KeyList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_CORBA_sequence_ConfigValue</NAME>
#define ORBIT_DECL_CORBA_sequence_ConfigValue 1
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigValue_0</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigValue_0 'G'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigValue_1</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigValue_1 'C'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigValue_2</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigValue_2 'o'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigValue_3</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigValue_3 'n'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigValue_4</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigValue_4 'f'
</MACRO>
<TYPEDEF>
<NAME>CORBA_sequence_ConfigValue</NAME>
   typedef struct {
      CORBA_unsigned_long _maximum,
       _length;
      ConfigValue *_buffer;
      CORBA_boolean _release;
   } CORBA_sequence_ConfigValue;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigValue_0</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigValue_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigValue_1</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigValue_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigValue_2</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigValue_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigValue_3</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigValue_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigValue_4</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigValue_4 'f'
</MACRO>
<MACRO>
<NAME>TC_CORBA_sequence_ConfigValue</NAME>
#define TC_CORBA_sequence_ConfigValue ((CORBA_TypeCode)&TC_CORBA_sequence_ConfigValue_struct)
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_ConfigValue__alloc</NAME>
<RETURNS>CORBA_sequence_ConfigValue  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_ConfigValue__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_ConfigValue_allocbuf</NAME>
<RETURNS>ConfigValue  *</RETURNS>
CORBA_unsigned_long len
</FUNCTION>
<TYPEDEF>
<NAME>ConfigServer_ValueList</NAME>
   typedef CORBA_sequence_ConfigValue ConfigServer_ValueList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_ValueList_0</NAME>
#define TC_IMPL_TC_ConfigServer_ValueList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_ValueList_1</NAME>
#define TC_IMPL_TC_ConfigServer_ValueList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_ValueList_2</NAME>
#define TC_IMPL_TC_ConfigServer_ValueList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_ValueList_3</NAME>
#define TC_IMPL_TC_ConfigServer_ValueList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_ValueList_4</NAME>
#define TC_IMPL_TC_ConfigServer_ValueList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigServer_ValueList</NAME>
#define TC_ConfigServer_ValueList ((CORBA_TypeCode)&TC_ConfigServer_ValueList_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigServer_ValueList__alloc</NAME>
<RETURNS>ConfigServer_ValueList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_ValueList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_CORBA_sequence_CORBA_boolean</NAME>
#define ORBIT_DECL_CORBA_sequence_CORBA_boolean 1
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_0</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_0 'G'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_1</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_1 'C'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_2</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_2 'o'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_3</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_3 'n'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_4</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_4 'f'
</MACRO>
<TYPEDEF>
<NAME>CORBA_sequence_CORBA_boolean</NAME>
   typedef struct {
      CORBA_unsigned_long _maximum,
       _length;
      CORBA_boolean *_buffer;
      CORBA_boolean _release;
   } CORBA_sequence_CORBA_boolean;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_0</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_1</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_2</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_3</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_4</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_4 'f'
</MACRO>
<MACRO>
<NAME>TC_CORBA_sequence_CORBA_boolean</NAME>
#define TC_CORBA_sequence_CORBA_boolean ((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_boolean_struct)
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_boolean__alloc</NAME>
<RETURNS>CORBA_sequence_CORBA_boolean  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_boolean__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_boolean_allocbuf</NAME>
<RETURNS>CORBA_boolean  *</RETURNS>
CORBA_unsigned_long len
</FUNCTION>
<TYPEDEF>
<NAME>ConfigServer_IsDefaultList</NAME>
   typedef CORBA_sequence_CORBA_boolean ConfigServer_IsDefaultList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_IsDefaultList_0</NAME>
#define TC_IMPL_TC_ConfigServer_IsDefaultList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_IsDefaultList_1</NAME>
#define TC_IMPL_TC_ConfigServer_IsDefaultList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_IsDefaultList_2</NAME>
#define TC_IMPL_TC_ConfigServer_IsDefaultList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_IsDefaultList_3</NAME>
#define TC_IMPL_TC_ConfigServer_IsDefaultList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_IsDefaultList_4</NAME>
#define TC_IMPL_TC_ConfigServer_IsDefaultList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigServer_IsDefaultList</NAME>
#define TC_ConfigServer_IsDefaultList ((CORBA_TypeCode)&TC_ConfigServer_IsDefaultList_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigServer_IsDefaultList__alloc</NAME>
<RETURNS>ConfigServer_IsDefaultList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_IsDefaultList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<TYPEDEF>
<NAME>ConfigServer_Context</NAME>
   typedef CORBA_unsigned_long ConfigServer_Context;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_Context_0</NAME>
#define TC_IMPL_TC_ConfigServer_Context_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_Context_1</NAME>
#define TC_IMPL_TC_ConfigServer_Context_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_Context_2</NAME>
#define TC_IMPL_TC_ConfigServer_Context_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_Context_3</NAME>
#define TC_IMPL_TC_ConfigServer_Context_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_Context_4</NAME>
#define TC_IMPL_TC_ConfigServer_Context_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigServer_Context</NAME>
#define TC_ConfigServer_Context ((CORBA_TypeCode)&TC_ConfigServer_Context_struct)
</MACRO>
<MACRO>
<NAME>ConfigServer_invalid_context</NAME>
#define ConfigServer_invalid_context 0
</MACRO>
<MACRO>
<NAME>ConfigServer_default_context</NAME>
#define ConfigServer_default_context 1
</MACRO>
<TYPEDEF>
<NAME>POA_ConfigListener__epv</NAME>
   typedef struct {
      void *_private;
      void (*notify) (PortableServer_Servant _servant, const CORBA_unsigned_long server_context, const CORBA_unsigned_long cnxn, const CORBA_char * key, const ConfigValue * value, const CORBA_boolean is_default, CORBA_Environment * ev);
   } POA_ConfigListener__epv;
</TYPEDEF>
<TYPEDEF>
<NAME>POA_ConfigListener__vepv</NAME>
   typedef struct {
      PortableServer_ServantBase__epv *_base_epv;
      POA_ConfigListener__epv *ConfigListener_epv;
   } POA_ConfigListener__vepv;
</TYPEDEF>
<TYPEDEF>
<NAME>POA_ConfigListener</NAME>
   typedef struct {
      void *_private;
      POA_ConfigListener__vepv *vepv;
   } POA_ConfigListener;
</TYPEDEF>
<FUNCTION>
<NAME>POA_ConfigListener__init</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>POA_ConfigListener__fini</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant, CORBA_Environment * ev
</FUNCTION>
<TYPEDEF>
<NAME>POA_ConfigServer__epv</NAME>
   typedef struct {
      void *_private;
       ConfigServer_Context(*get_context) (PortableServer_Servant _servant, const CORBA_char * address, CORBA_Environment * ev);
       CORBA_unsigned_long(*add_listener) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * where, const ConfigListener who, CORBA_Environment * ev);
      void (*remove_listener) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_unsigned_long cnxn, CORBA_Environment * ev);
      ConfigValue *(*lookup) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * key, CORBA_Environment * ev);
      ConfigValue *(*lookup_with_locale) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * key, const CORBA_char * locale, const CORBA_boolean use_schema_default, CORBA_boolean * value_is_default, CORBA_Environment * ev);
      ConfigValue *(*lookup_default_value) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * key, const CORBA_char * locale, CORBA_Environment * ev);
      void (*set) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * key, const ConfigValue * value, CORBA_Environment * ev);
      void (*unset) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * key, CORBA_Environment * ev);
      void (*unset_with_locale) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * key, const CORBA_char * locale, CORBA_Environment * ev);
       CORBA_boolean(*dir_exists) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * dir, CORBA_Environment * ev);
      void (*remove_dir) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * dir, CORBA_Environment * ev);
      void (*all_entries) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * dir, const CORBA_char * locale, ConfigServer_KeyList ** keys, ConfigServer_ValueList ** values, ConfigServer_IsDefaultList ** is_defaults, CORBA_Environment * ev);
      void (*all_dirs) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * dir, ConfigServer_KeyList ** subdirs, CORBA_Environment * ev);
      void (*set_schema) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * key, const CORBA_char * schema_key, CORBA_Environment * ev);
      void (*sync) (PortableServer_Servant _servant, const ConfigServer_Context ctx, CORBA_Environment * ev);
       CORBA_long(*ping) (PortableServer_Servant _servant, CORBA_Environment * ev);
      void (*shutdown) (PortableServer_Servant _servant, CORBA_Environment * ev);
      void (*clear_cache) (PortableServer_Servant _servant, const ConfigServer_Context ctx, CORBA_Environment * ev);
      void (*synchronous_sync) (PortableServer_Servant _servant, const ConfigServer_Context ctx, CORBA_Environment * ev);
   } POA_ConfigServer__epv;
</TYPEDEF>
<TYPEDEF>
<NAME>POA_ConfigServer__vepv</NAME>
   typedef struct {
      PortableServer_ServantBase__epv *_base_epv;
      POA_ConfigServer__epv *ConfigServer_epv;
   } POA_ConfigServer__vepv;
</TYPEDEF>
<TYPEDEF>
<NAME>POA_ConfigServer</NAME>
   typedef struct {
      void *_private;
      POA_ConfigServer__vepv *vepv;
   } POA_ConfigServer;
</TYPEDEF>
<FUNCTION>
<NAME>POA_ConfigServer__init</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>POA_ConfigServer__fini</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigListener_notify</NAME>
<RETURNS>void  </RETURNS>
ConfigListener _obj, const CORBA_unsigned_long server_context, const CORBA_unsigned_long cnxn, const CORBA_char * key, const ConfigValue * value, const CORBA_boolean is_default, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_get_context</NAME>
<RETURNS>ConfigServer_Context  </RETURNS>
ConfigServer _obj, const CORBA_char * address, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_add_listener</NAME>
<RETURNS>CORBA_unsigned_long  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * where, const ConfigListener who, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_remove_listener</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_unsigned_long cnxn, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_lookup</NAME>
<RETURNS>ConfigValue  *</RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * key, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_lookup_with_locale</NAME>
<RETURNS>ConfigValue  *</RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * key, const CORBA_char * locale, const CORBA_boolean use_schema_default, CORBA_boolean * value_is_default, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_lookup_default_value</NAME>
<RETURNS>ConfigValue  *</RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * key, const CORBA_char * locale, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_set</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * key, const ConfigValue * value, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_unset</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * key, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_unset_with_locale</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * key, const CORBA_char * locale, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_dir_exists</NAME>
<RETURNS>CORBA_boolean  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * dir, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_remove_dir</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * dir, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_all_entries</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * dir, const CORBA_char * locale, ConfigServer_KeyList ** keys, ConfigServer_ValueList ** values, ConfigServer_IsDefaultList ** is_defaults, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_all_dirs</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * dir, ConfigServer_KeyList ** subdirs, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_set_schema</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * key, const CORBA_char * schema_key, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_sync</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_ping</NAME>
<RETURNS>CORBA_long  </RETURNS>
ConfigServer _obj, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_shutdown</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_clear_cache</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_synchronous_sync</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>gconf_key_directory</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* key
</FUNCTION>
<FUNCTION>
<NAME>gconf_key_key</NAME>
<RETURNS>const gchar *</RETURNS>
const gchar* key
</FUNCTION>
<FUNCTION>
<NAME>gconf_file_test</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar* filename, int test
</FUNCTION>
<FUNCTION>
<NAME>gconf_file_exists</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar* filename
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_from_corba_value</NAME>
<RETURNS>GConfValue *</RETURNS>
const ConfigValue* value
</FUNCTION>
<FUNCTION>
<NAME>corba_value_from_gconf_value</NAME>
<RETURNS>ConfigValue *</RETURNS>
GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>fill_corba_value_from_gconf_value</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,ConfigValue* dest
</FUNCTION>
<FUNCTION>
<NAME>invalid_corba_value</NAME>
<RETURNS>ConfigValue *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>fill_corba_schema_from_gconf_schema</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc,ConfigSchema* dest
</FUNCTION>
<FUNCTION>
<NAME>corba_schema_from_gconf_schema</NAME>
<RETURNS>ConfigSchema *</RETURNS>
GConfSchema* sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_from_corba_schema</NAME>
<RETURNS>GConfSchema *</RETURNS>
const ConfigSchema* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_type_to_string</NAME>
<RETURNS>const gchar *</RETURNS>
GConfValueType type
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_type_from_string</NAME>
<RETURNS>GConfValueType  </RETURNS>
const gchar* str
</FUNCTION>
<FUNCTION>
<NAME>gconf_load_source_path</NAME>
<RETURNS>gchar **</RETURNS>
const gchar* filename, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_shutdown_daemon</NAME>
<RETURNS>void  </RETURNS>
GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_ping_daemon</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_spawn_daemon</NAME>
<RETURNS>gboolean  </RETURNS>
GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_string_to_gulong</NAME>
<RETURNS>gulong  </RETURNS>
const gchar* str
</FUNCTION>
<FUNCTION>
<NAME>gconf_string_to_double</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar* str, gdouble* val
</FUNCTION>
<FUNCTION>
<NAME>gconf_double_to_string</NAME>
<RETURNS>gchar *</RETURNS>
gdouble val
</FUNCTION>
<FUNCTION>
<NAME>gconf_current_locale</NAME>
<RETURNS>const gchar *</RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GConfLogPriority</NAME>
typedef enum {
  GCL_EMERG,
  GCL_ALERT,
  GCL_CRIT,
  GCL_ERR,
  GCL_WARNING,
  GCL_NOTICE,
  GCL_INFO,
  GCL_DEBUG
} GConfLogPriority;
</ENUM>
<FUNCTION>
<NAME>gconf_log</NAME>
<RETURNS>void  </RETURNS>
GConfLogPriority pri, const gchar* format, ...
</FUNCTION>
<FUNCTION>
<NAME>gconf_key_check</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar* key, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_new_from_string</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType type, const gchar* str,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_new_list_from_string</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType list_type,const gchar* str
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_new_pair_from_string</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType car_type,GConfValueType cdr_type,const gchar* str
</FUNCTION>
<FUNCTION>
<NAME>gconf_quote_string</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* str
</FUNCTION>
<FUNCTION>
<NAME>gconf_unquote_string</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* str, const gchar** end, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_unquote_string_inplace</NAME>
<RETURNS>void  </RETURNS>
gchar* str, gchar** end, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_decode</NAME>
<RETURNS>GConfValue *</RETURNS>
const gchar* encoded
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_encode</NAME>
<RETURNS>gchar *</RETURNS>
GConfValue* val
</FUNCTION>
<FUNCTION>
<NAME>gconf_quote_percents</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* src
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_list_from_primitive_list</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType list_type, GSList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_pair_from_primitive_pair</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType car_type,GConfValueType cdr_type,gconstpointer address_of_car,gconstpointer address_of_cdr
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_list_to_primitive_list_destructive</NAME>
<RETURNS>GSList *</RETURNS>
GConfValue* val,GConfValueType list_type,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_pair_to_primitive_pair_destructive</NAME>
<RETURNS>gboolean  </RETURNS>
GConfValue* val,GConfValueType car_type,GConfValueType cdr_type,gpointer car_retloc,gpointer cdr_retloc,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_daemon_mode</NAME>
<RETURNS>void  </RETURNS>
gboolean setting
</FUNCTION>
<FUNCTION>
<NAME>gconf_in_daemon_mode</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_daemon_ior</NAME>
<RETURNS>void  </RETURNS>
const gchar* ior
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_daemon_ior</NAME>
<RETURNS>const gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_handle_oaf_exception</NAME>
<RETURNS>gboolean  </RETURNS>
CORBA_Environment* ev, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_nanosleep</NAME>
<RETURNS>void  </RETURNS>
gulong useconds
</FUNCTION>
<STRUCT>
<NAME>GConfLock</NAME>
</STRUCT>
<FUNCTION>
<NAME>gconf_get_lock</NAME>
<RETURNS>GConfLock *</RETURNS>
const gchar* lock_directory,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_release_lock</NAME>
<RETURNS>gboolean  </RETURNS>
GConfLock* lock,GError** err
</FUNCTION>
<STRUCT>
<NAME>GConfChangeSet</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GConfChangeSetForeachFunc</NAME>
<RETURNS>void </RETURNS>
GConfChangeSet* cs,
                                            const gchar* key,
                                            GConfValue* value,
                                            gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gconf_commit_change_set</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine* conf,GConfChangeSet* cs,gboolean remove_committed,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_create_reverse_change_set</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfEngine* conf,GConfChangeSet* cs,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_create_change_set_from_currentv</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfEngine* conf,const gchar** keys,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_create_change_set_from_current</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfEngine* conf,GError** err,const gchar* first_key,...
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_new</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_ref</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_unref</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_clear</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_size</NAME>
<RETURNS>guint  </RETURNS>
GConfChangeSet* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_remove</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs,const gchar* key
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_foreach</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs,GConfChangeSetForeachFunc func,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_check_value</NAME>
<RETURNS>gboolean  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValue** value_retloc
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_unset</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_float</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,gdouble val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_int</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,gint val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_string</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,const gchar* val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_bool</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,gboolean val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfSchema* val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_list</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValueType list_type,GSList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_pair</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValueType car_type, GConfValueType cdr_type,gconstpointer address_of_car,gconstpointer address_of_cdr
</FUNCTION>
<FUNCTION>
<NAME>gce_app_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar* geometry
</FUNCTION>
<FUNCTION>
<NAME>gce_app_close</NAME>
<RETURNS>void</RETURNS>
GtkWidget* app
</FUNCTION>
<FUNCTION>
<NAME>gce_install_menus_and_toolbar</NAME>
<RETURNS>void  </RETURNS>
GtkWidget* app
</FUNCTION>
<FUNCTION>
<NAME>set</NAME>
<RETURNS>void  </RETURNS>
const string& key, int val
</FUNCTION>
<FUNCTION>
<NAME>set</NAME>
<RETURNS>void  </RETURNS>
const string& key, bool val
</FUNCTION>
<FUNCTION>
<NAME>set</NAME>
<RETURNS>void  </RETURNS>
const string& key, double val
</FUNCTION>
<FUNCTION>
<NAME>set</NAME>
<RETURNS>void  </RETURNS>
const string& key, const string& val
</FUNCTION>
<FUNCTION>
<NAME>set</NAME>
<RETURNS>void  </RETURNS>
const string& key, const vector<string>& val
</FUNCTION>
<FUNCTION>
<NAME>set</NAME>
<RETURNS>void  </RETURNS>
const string& key, const vector<int>& val
</FUNCTION>
<FUNCTION>
<NAME>set</NAME>
<RETURNS>void  </RETURNS>
const string& key, const vector<bool>& val
</FUNCTION>
<FUNCTION>
<NAME>set</NAME>
<RETURNS>void  </RETURNS>
const string& key, const vector<double>& val
</FUNCTION>
<FUNCTION>
<NAME>unset</NAME>
<RETURNS>void  </RETURNS>
const string& key
</FUNCTION>
<FUNCTION>
<NAME>get</NAME>
<RETURNS>bool  </RETURNS>
const string& key, int* val
</FUNCTION>
<FUNCTION>
<NAME>get</NAME>
<RETURNS>bool  </RETURNS>
const string& key, bool* val
</FUNCTION>
<FUNCTION>
<NAME>get</NAME>
<RETURNS>bool  </RETURNS>
const string& key, double* val
</FUNCTION>
<FUNCTION>
<NAME>get</NAME>
<RETURNS>bool  </RETURNS>
const string& key, string* val
</FUNCTION>
<FUNCTION>
<NAME>get</NAME>
<RETURNS>bool  </RETURNS>
const string& key, vector<string>* val
</FUNCTION>
<FUNCTION>
<NAME>get</NAME>
<RETURNS>bool  </RETURNS>
const string& key, vector<int>* val
</FUNCTION>
<FUNCTION>
<NAME>get</NAME>
<RETURNS>bool  </RETURNS>
const string& key, vector<bool>* val
</FUNCTION>
<FUNCTION>
<NAME>get</NAME>
<RETURNS>bool  </RETURNS>
const string& key, vector<double>* val
</FUNCTION>
<ENUM>
<NAME>GConfClientPreloadType</NAME>
typedef enum {
  GCONF_CLIENT_PRELOAD_NONE,     /* don't preload anything */
  GCONF_CLIENT_PRELOAD_ONELEVEL, /* load entries directly under the directory. */
  GCONF_CLIENT_PRELOAD_RECURSIVE /* recurse the directory tree; possibly quite expensive! */
} GConfClientPreloadType;
</ENUM>
<ENUM>
<NAME>GConfClientErrorHandlingMode</NAME>
typedef enum {
  GCONF_CLIENT_HANDLE_NONE,
  GCONF_CLIENT_HANDLE_UNRETURNED,
  GCONF_CLIENT_HANDLE_ALL
} GConfClientErrorHandlingMode;
</ENUM>
<STRUCT>
<NAME>GConfClient</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfClientClass</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GConfClientNotifyFunc</NAME>
<RETURNS>void </RETURNS>
GConfClient* client, guint cnxn_id, const gchar* key, GConfValue* value, gboolean is_default, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GConfClientParentWindowFunc</NAME>
<RETURNS>GtkWidget *</RETURNS>
GConfClient* client, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GConfClientErrorHandlerFunc</NAME>
<RETURNS>void </RETURNS>
GConfClient* client, GConfClientParentWindowFunc parent_func, gpointer parent_user_data, GError* error
</USER_FUNCTION>
<MACRO>
<NAME>GCONF_TYPE_CLIENT</NAME>
#define GCONF_TYPE_CLIENT                  (gconf_client_get_type ())
</MACRO>
<MACRO>
<NAME>GCONF_CLIENT</NAME>
#define GCONF_CLIENT(obj)                  (GTK_CHECK_CAST ((obj), GCONF_TYPE_CLIENT, GConfClient))
</MACRO>
<MACRO>
<NAME>GCONF_CLIENT_CLASS</NAME>
#define GCONF_CLIENT_CLASS(klass)          (CONF_CHECK_CLASS_CAST ((klass), GCONF_TYPE_CLIENT, GConfClientClass))
</MACRO>
<MACRO>
<NAME>GCONF_IS_CLIENT</NAME>
#define GCONF_IS_CLIENT(obj)               (GTK_CHECK_TYPE ((obj), GCONF_TYPE_CLIENT))
</MACRO>
<MACRO>
<NAME>GCONF_IS_CLIENT_CLASS</NAME>
#define GCONF_IS_CLIENT_CLASS(klass)       (CONF_CHECK_CLASS_TYPE ((klass), GCONF_TYPE_CLIENT))
</MACRO>
<STRUCT>
<NAME>GConfClient</NAME>
struct GConfClient
{
  GtkObject object;

  /*< private >*/

  GConfEngine* engine;
  GConfClientErrorHandlingMode error_mode;
  GConfClientParentWindowFunc parent_func;
  gpointer parent_user_data;
  GHashTable* dir_hash;
  GHashTable* cache_hash;
  GConfListeners* listeners;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_client_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_new</NAME>
<RETURNS>GConfClient *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_new_with_engine</NAME>
<RETURNS>GConfClient *</RETURNS>
GConfEngine* engine
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_add_dir</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* dir,GConfClientPreloadType preload,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_remove_dir</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* dir
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_notify_add</NAME>
<RETURNS>guint  </RETURNS>
GConfClient* client,const gchar* namespace_section,GConfClientNotifyFunc func,gpointer user_data,GFreeFunc destroy_notify,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_notify_remove</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,guint cnxn
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_error_handling</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,GConfClientErrorHandlingMode mode,GConfClientParentWindowFunc func,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_global_default_error_handler</NAME>
<RETURNS>void  </RETURNS>
GConfClientErrorHandlerFunc func
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_clear_cache</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_preload</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* dirname,GConfClientPreloadType type,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* key,GConfValue* val,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfClient* client,const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_without_default</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfClient* client,const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_full</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfClient* client,const gchar* key, const gchar* locale,gboolean use_schema_default,gboolean* value_is_default,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_default_from_schema</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfClient* client,const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_unset</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client,const gchar* key, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
GConfClient* client,const gchar* dir, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_all_dirs</NAME>
<RETURNS>GSList *</RETURNS>
GConfClient* client,const gchar* dir, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_suggest_sync</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_dir_exists</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client,const gchar* dir, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_float</NAME>
<RETURNS>gdouble  </RETURNS>
GConfClient* client, const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_int</NAME>
<RETURNS>gint  </RETURNS>
GConfClient* client, const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_string</NAME>
<RETURNS>gchar *</RETURNS>
GConfClient* client, const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_bool</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_schema</NAME>
<RETURNS>GConfSchema *</RETURNS>
GConfClient* client,const gchar* key, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_list</NAME>
<RETURNS>GSList *</RETURNS>
GConfClient* client, const gchar* key,GConfValueType list_type, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_pair</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GConfValueType car_type, GConfValueType cdr_type,gpointer car_retloc, gpointer cdr_retloc,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_float</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,gdouble val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_int</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,gint val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_string</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,const gchar* val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_bool</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,gboolean val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_schema</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GConfSchema* val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_list</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GConfValueType list_type,GSList* list,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_pair</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GConfValueType car_type, GConfValueType cdr_type,gconstpointer address_of_car,gconstpointer address_of_cdr,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_error</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client, GError* error
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_unreturned_error</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client, GError* error
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_value_changed</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* key,GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_commit_change_set</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client,GConfChangeSet* cs,gboolean remove_committed,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_create_reverse_change_set</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfClient* client,GConfChangeSet* cs,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_create_change_set_from_currentv</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfClient* client,const gchar** keys,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_create_change_set_from_current</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfClient* client,GError** err,const gchar* first_key,...
</FUNCTION>
<MACRO>
<NAME>GCONF_PROC</NAME>
#define GCONF_PROC(fname,primname, req, opt, var, ARGLIST) \
        SCM_PROC(s_ ## fname, primname, req, opt, var, fname); \
static SCM fname ARGLIST
</MACRO>
<MACRO>
<NAME>GCONF_PROC</NAME>
#define GCONF_PROC(fname,primname, req, opt, var, ARGLIST) \
        SCM_PROC(s_ ## fname, primname, req, opt, var, fname);
</MACRO>
<FUNCTION>
<NAME>gconf_init_scm</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>scm_gconfp</NAME>
<RETURNS>gboolean  </RETURNS>
SCM obj
</FUNCTION>
<FUNCTION>
<NAME>scm2gconf</NAME>
<RETURNS>GConfEngine *</RETURNS>
SCM obj
</FUNCTION>
<FUNCTION>
<NAME>gconf2scm</NAME>
<RETURNS>SCM  </RETURNS>
GConfEngine* conf
</FUNCTION>
<MACRO>
<NAME>MO_REVISION_NUMBER</NAME>
#define MO_REVISION_NUMBER 0
</MACRO>
<MACRO>
<NAME>UINT_MAX_32_BITS</NAME>
# define UINT_MAX_32_BITS 4294967295U
</MACRO>
<MACRO>
<NAME>UINT_MAX_32_BITS</NAME>
# define UINT_MAX_32_BITS 0xFFFFFFFF
</MACRO>
<MACRO>
<NAME>UINT_MAX</NAME>
# define UINT_MAX UINT_MAX_32_BITS
</MACRO>
<TYPEDEF>
<NAME>nls_uint32</NAME>
typedef unsigned nls_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>nls_uint32</NAME>
typedef unsigned short nls_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>nls_uint32</NAME>
typedef unsigned long nls_uint32;
</TYPEDEF>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) args
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) ()
</MACRO>
<MACRO>
<NAME>internal_function</NAME>
# define internal_function
</MACRO>
<MACRO>
<NAME>W</NAME>
# define W(flag, data) ((flag) ? SWAP (data) : (data))
</MACRO>
<MACRO>
<NAME>SWAP</NAME>
# define SWAP(i) bswap_32 (i)
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(Args) Args
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(Args) ()
</MACRO>
<MACRO>
<NAME>HASHWORDBITS</NAME>
#define HASHWORDBITS 32
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) args
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) ()
</MACRO>
<MACRO>
<NAME>NULL</NAME>
#  define NULL ((void *) 0)
</MACRO>
<MACRO>
<NAME>NULL</NAME>
#  define NULL (0)
</MACRO>
<MACRO>
<NAME>LC_MESSAGES</NAME>
# define LC_MESSAGES (-1)
</MACRO>
<STRUCT>
<NAME>msg_ent</NAME>
struct msg_ent
{
  const char *_msg;
  int _msg_number;
};
</STRUCT>
<MACRO>
<NAME>gettext_noop</NAME>
#define gettext_noop(Str) (Str)
</MACRO>
<MACRO>
<NAME>gettext</NAME>
#  define gettext(Msgid)						      \
     dgettext (NULL, Msgid)
</MACRO>
<MACRO>
<NAME>dgettext</NAME>
#  define dgettext(Domainname, Msgid)					      \
     dcgettext (Domainname, Msgid, LC_MESSAGES)
</MACRO>
<MACRO>
<NAME>dcgettext</NAME>
#   define dcgettext(Domainname, Msgid, Category)			      \
  (__extension__							      \
   ({									      \
     char *__result;							      \
     if (__builtin_constant_p (Msgid))					      \
       {								      \
	 static char *__translation__;					      \
	 static int __catalog_counter__;				      \
	 if (! __translation__ || __catalog_counter__ != _nl_msg_cat_cntr)    \
	   {								      \
	     __translation__ =						      \
	       dcgettext__ (Domainname, Msgid, Category);		      \
	     __catalog_counter__ = _nl_msg_cat_cntr;			      \
	   }								      \
	 __result = __translation__;					      \
       }								      \
     else								      \
       __result = dcgettext__ (Domainname, Msgid, Category);		      \
     __result;								      \
    }))
</MACRO>
<MACRO>
<NAME>gettext</NAME>
# define gettext(Msgid) (Msgid)
</MACRO>
<MACRO>
<NAME>dgettext</NAME>
# define dgettext(Domainname, Msgid) (Msgid)
</MACRO>
<MACRO>
<NAME>dcgettext</NAME>
# define dcgettext(Domainname, Msgid, Category) (Msgid)
</MACRO>
<MACRO>
<NAME>textdomain</NAME>
# define textdomain(Domainname) ((char *) Domainname)
</MACRO>
<MACRO>
<NAME>bindtextdomain</NAME>
# define bindtextdomain(Domainname, Dirname) ((char *) Dirname)
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) args
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) ()
</MACRO>
<MACRO>
<NAME>CEN_REVISION</NAME>
#define CEN_REVISION		1
</MACRO>
<MACRO>
<NAME>CEN_SPONSOR</NAME>
#define CEN_SPONSOR		2
</MACRO>
<MACRO>
<NAME>CEN_SPECIAL</NAME>
#define CEN_SPECIAL		4
</MACRO>
<MACRO>
<NAME>XPG_NORM_CODESET</NAME>
#define XPG_NORM_CODESET	8
</MACRO>
<MACRO>
<NAME>XPG_CODESET</NAME>
#define XPG_CODESET		16
</MACRO>
<MACRO>
<NAME>TERRITORY</NAME>
#define TERRITORY		32
</MACRO>
<MACRO>
<NAME>CEN_AUDIENCE</NAME>
#define CEN_AUDIENCE		64
</MACRO>
<MACRO>
<NAME>XPG_MODIFIER</NAME>
#define XPG_MODIFIER		128
</MACRO>
<MACRO>
<NAME>CEN_SPECIFIC</NAME>
#define CEN_SPECIFIC	(CEN_REVISION|CEN_SPONSOR|CEN_SPECIAL|CEN_AUDIENCE)
</MACRO>
<MACRO>
<NAME>XPG_SPECIFIC</NAME>
#define XPG_SPECIFIC	(XPG_CODESET|XPG_NORM_CODESET|XPG_MODIFIER)
</MACRO>
<FUNCTION>
<NAME>PARAMS</NAME>
<RETURNS>_nl_make_l10nflist  </RETURNS>
(struct loaded_l10nfile **l10nfile_list,const char *dirlist, size_t dirlist_len, int mask,const char *language, const char *territory,const char *codeset,const char *normalized_codeset,const char *modifier, const char *special,const char *sponsor, const char *revision,const char *filename, int do_allocate)
</FUNCTION>
<FUNCTION>
<NAME>gconf_key_directory</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* key
</FUNCTION>
<FUNCTION>
<NAME>gconf_key_key</NAME>
<RETURNS>const gchar *</RETURNS>
const gchar* key
</FUNCTION>
<FUNCTION>
<NAME>gconf_file_test</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar* filename, int test
</FUNCTION>
<FUNCTION>
<NAME>gconf_file_exists</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar* filename
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_from_corba_value</NAME>
<RETURNS>GConfValue *</RETURNS>
const ConfigValue* value
</FUNCTION>
<FUNCTION>
<NAME>corba_value_from_gconf_value</NAME>
<RETURNS>ConfigValue *</RETURNS>
GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>fill_corba_value_from_gconf_value</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,ConfigValue* dest
</FUNCTION>
<FUNCTION>
<NAME>invalid_corba_value</NAME>
<RETURNS>ConfigValue *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>fill_corba_schema_from_gconf_schema</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc,ConfigSchema* dest
</FUNCTION>
<FUNCTION>
<NAME>corba_schema_from_gconf_schema</NAME>
<RETURNS>ConfigSchema *</RETURNS>
GConfSchema* sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_from_corba_schema</NAME>
<RETURNS>GConfSchema *</RETURNS>
const ConfigSchema* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_type_to_string</NAME>
<RETURNS>const gchar *</RETURNS>
GConfValueType type
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_type_from_string</NAME>
<RETURNS>GConfValueType  </RETURNS>
const gchar* str
</FUNCTION>
<FUNCTION>
<NAME>gconf_load_source_path</NAME>
<RETURNS>gchar **</RETURNS>
const gchar* filename, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_shutdown_daemon</NAME>
<RETURNS>void  </RETURNS>
GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_ping_daemon</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_spawn_daemon</NAME>
<RETURNS>gboolean  </RETURNS>
GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_string_to_gulong</NAME>
<RETURNS>gulong  </RETURNS>
const gchar* str
</FUNCTION>
<FUNCTION>
<NAME>gconf_string_to_double</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar* str, gdouble* val
</FUNCTION>
<FUNCTION>
<NAME>gconf_double_to_string</NAME>
<RETURNS>gchar *</RETURNS>
gdouble val
</FUNCTION>
<FUNCTION>
<NAME>gconf_current_locale</NAME>
<RETURNS>const gchar *</RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GConfLogPriority</NAME>
typedef enum {
  GCL_EMERG,
  GCL_ALERT,
  GCL_CRIT,
  GCL_ERR,
  GCL_WARNING,
  GCL_NOTICE,
  GCL_INFO,
  GCL_DEBUG
} GConfLogPriority;
</ENUM>
<FUNCTION>
<NAME>gconf_log</NAME>
<RETURNS>void  </RETURNS>
GConfLogPriority pri, const gchar* format, ...
</FUNCTION>
<FUNCTION>
<NAME>gconf_key_check</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar* key, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_new_from_string</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType type, const gchar* str,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_new_list_from_string</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType list_type,const gchar* str
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_new_pair_from_string</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType car_type,GConfValueType cdr_type,const gchar* str
</FUNCTION>
<FUNCTION>
<NAME>gconf_quote_string</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* str
</FUNCTION>
<FUNCTION>
<NAME>gconf_unquote_string</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* str, const gchar** end, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_unquote_string_inplace</NAME>
<RETURNS>void  </RETURNS>
gchar* str, gchar** end, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_decode</NAME>
<RETURNS>GConfValue *</RETURNS>
const gchar* encoded
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_encode</NAME>
<RETURNS>gchar *</RETURNS>
GConfValue* val
</FUNCTION>
<FUNCTION>
<NAME>gconf_quote_percents</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* src
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_list_from_primitive_list</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType list_type, GSList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_pair_from_primitive_pair</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType car_type,GConfValueType cdr_type,gconstpointer address_of_car,gconstpointer address_of_cdr
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_list_to_primitive_list_destructive</NAME>
<RETURNS>GSList *</RETURNS>
GConfValue* val,GConfValueType list_type,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_pair_to_primitive_pair_destructive</NAME>
<RETURNS>gboolean  </RETURNS>
GConfValue* val,GConfValueType car_type,GConfValueType cdr_type,gpointer car_retloc,gpointer cdr_retloc,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_daemon_mode</NAME>
<RETURNS>void  </RETURNS>
gboolean setting
</FUNCTION>
<FUNCTION>
<NAME>gconf_in_daemon_mode</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_daemon_ior</NAME>
<RETURNS>void  </RETURNS>
const gchar* ior
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_daemon_ior</NAME>
<RETURNS>const gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_handle_oaf_exception</NAME>
<RETURNS>gboolean  </RETURNS>
CORBA_Environment* ev, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_nanosleep</NAME>
<RETURNS>void  </RETURNS>
gulong useconds
</FUNCTION>
<STRUCT>
<NAME>GConfLock</NAME>
</STRUCT>
<FUNCTION>
<NAME>gconf_get_lock</NAME>
<RETURNS>GConfLock *</RETURNS>
const gchar* lock_directory,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_release_lock</NAME>
<RETURNS>gboolean  </RETURNS>
GConfLock* lock,GError** err
</FUNCTION>
<STRUCT>
<NAME>GConfLocaleCache</NAME>
</STRUCT>
<FUNCTION>
<NAME>gconf_locale_cache_new</NAME>
<RETURNS>GConfLocaleCache *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_locale_cache_destroy</NAME>
<RETURNS>void  </RETURNS>
GConfLocaleCache* cache
</FUNCTION>
<FUNCTION>
<NAME>gconf_locale_cache_expire</NAME>
<RETURNS>void  </RETURNS>
GConfLocaleCache* cache,guint max_age_exclusive_in_seconds
</FUNCTION>
<STRUCT>
<NAME>GConfLocaleList</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfLocaleList</NAME>
struct GConfLocaleList {
  const gchar** list;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_locale_list_ref</NAME>
<RETURNS>void  </RETURNS>
GConfLocaleList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_locale_list_unref</NAME>
<RETURNS>void  </RETURNS>
GConfLocaleList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_locale_cache_get_list</NAME>
<RETURNS>GConfLocaleList *</RETURNS>
GConfLocaleCache* cache,const gchar* locale
</FUNCTION>
<FUNCTION>
<NAME>gconf_split_locale</NAME>
<RETURNS>gchar **</RETURNS>
const gchar* locale
</FUNCTION>
<MACRO>
<NAME>ORBIT_IDL_SERIAL</NAME>
#define ORBIT_IDL_SERIAL 9
</MACRO>
<MACRO>
<NAME>GConf_H</NAME>
#define GConf_H 1
</MACRO>
<ENUM>
<NAME>ConfigBasicValueType</NAME>
   typedef enum {
      BInvalidVal,
      BIntVal,
      BStringVal,
      BFloatVal,
      BBoolVal,
      BSchemaVal
   } ConfigBasicValueType;
</ENUM>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValueType_0</NAME>
#define TC_IMPL_TC_ConfigBasicValueType_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValueType_1</NAME>
#define TC_IMPL_TC_ConfigBasicValueType_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValueType_2</NAME>
#define TC_IMPL_TC_ConfigBasicValueType_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValueType_3</NAME>
#define TC_IMPL_TC_ConfigBasicValueType_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValueType_4</NAME>
#define TC_IMPL_TC_ConfigBasicValueType_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigBasicValueType</NAME>
#define TC_ConfigBasicValueType ((CORBA_TypeCode)&TC_ConfigBasicValueType_struct)
</MACRO>
<ENUM>
<NAME>ConfigValueType</NAME>
   typedef enum {
      InvalidVal,
      IntVal,
      StringVal,
      FloatVal,
      BoolVal,
      SchemaVal,
      ListVal,
      PairVal
   } ConfigValueType;
</ENUM>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValueType_0</NAME>
#define TC_IMPL_TC_ConfigValueType_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValueType_1</NAME>
#define TC_IMPL_TC_ConfigValueType_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValueType_2</NAME>
#define TC_IMPL_TC_ConfigValueType_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValueType_3</NAME>
#define TC_IMPL_TC_ConfigValueType_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValueType_4</NAME>
#define TC_IMPL_TC_ConfigValueType_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigValueType</NAME>
#define TC_ConfigValueType ((CORBA_TypeCode)&TC_ConfigValueType_struct)
</MACRO>
<TYPEDEF>
<NAME>ConfigSchema</NAME>
   typedef struct {
      ConfigValueType value_type;
      CORBA_char *locale;
      CORBA_char *short_desc;
      CORBA_char *long_desc;
      CORBA_char *owner;
      CORBA_char *encoded_default_value;
   } ConfigSchema;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigSchema_0</NAME>
#define TC_IMPL_TC_ConfigSchema_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigSchema_1</NAME>
#define TC_IMPL_TC_ConfigSchema_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigSchema_2</NAME>
#define TC_IMPL_TC_ConfigSchema_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigSchema_3</NAME>
#define TC_IMPL_TC_ConfigSchema_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigSchema_4</NAME>
#define TC_IMPL_TC_ConfigSchema_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigSchema</NAME>
#define TC_ConfigSchema ((CORBA_TypeCode)&TC_ConfigSchema_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigSchema__alloc</NAME>
<RETURNS>ConfigSchema  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigSchema__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<TYPEDEF>
<NAME>ConfigBasicValue</NAME>
   typedef struct {
      ConfigBasicValueType _d;
      union {
	 CORBA_long dummy;
	 CORBA_long int_value;
	 CORBA_char *string_value;
	 CORBA_float float_value;
	 CORBA_boolean bool_value;
	 ConfigSchema schema_value;
      } _u;
   } ConfigBasicValue;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValue_0</NAME>
#define TC_IMPL_TC_ConfigBasicValue_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValue_1</NAME>
#define TC_IMPL_TC_ConfigBasicValue_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValue_2</NAME>
#define TC_IMPL_TC_ConfigBasicValue_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValue_3</NAME>
#define TC_IMPL_TC_ConfigBasicValue_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValue_4</NAME>
#define TC_IMPL_TC_ConfigBasicValue_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigBasicValue</NAME>
#define TC_ConfigBasicValue ((CORBA_TypeCode)&TC_ConfigBasicValue_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigBasicValue__alloc</NAME>
<RETURNS>ConfigBasicValue  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigBasicValue__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_CORBA_sequence_ConfigBasicValue</NAME>
#define ORBIT_DECL_CORBA_sequence_ConfigBasicValue 1
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_0</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_0 'G'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_1</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_1 'C'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_2</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_2 'o'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_3</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_3 'n'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_4</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_4 'f'
</MACRO>
<TYPEDEF>
<NAME>CORBA_sequence_ConfigBasicValue</NAME>
   typedef struct {
      CORBA_unsigned_long _maximum,
       _length;
      ConfigBasicValue *_buffer;
      CORBA_boolean _release;
   } CORBA_sequence_ConfigBasicValue;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_0</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_1</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_2</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_3</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_4</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_4 'f'
</MACRO>
<MACRO>
<NAME>TC_CORBA_sequence_ConfigBasicValue</NAME>
#define TC_CORBA_sequence_ConfigBasicValue ((CORBA_TypeCode)&TC_CORBA_sequence_ConfigBasicValue_struct)
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_ConfigBasicValue__alloc</NAME>
<RETURNS>CORBA_sequence_ConfigBasicValue  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_ConfigBasicValue__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_ConfigBasicValue_allocbuf</NAME>
<RETURNS>ConfigBasicValue  *</RETURNS>
CORBA_unsigned_long len
</FUNCTION>
<TYPEDEF>
<NAME>BasicValueList</NAME>
   typedef CORBA_sequence_ConfigBasicValue BasicValueList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_BasicValueList_0</NAME>
#define TC_IMPL_TC_BasicValueList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_BasicValueList_1</NAME>
#define TC_IMPL_TC_BasicValueList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_BasicValueList_2</NAME>
#define TC_IMPL_TC_BasicValueList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_BasicValueList_3</NAME>
#define TC_IMPL_TC_BasicValueList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_BasicValueList_4</NAME>
#define TC_IMPL_TC_BasicValueList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_BasicValueList</NAME>
#define TC_BasicValueList ((CORBA_TypeCode)&TC_BasicValueList_struct)
</MACRO>
<FUNCTION>
<NAME>BasicValueList__alloc</NAME>
<RETURNS>BasicValueList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>BasicValueList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<TYPEDEF>
<NAME>ConfigList</NAME>
   typedef struct {
      BasicValueList seq;
      ConfigBasicValueType list_type;
   } ConfigList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigList_0</NAME>
#define TC_IMPL_TC_ConfigList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigList_1</NAME>
#define TC_IMPL_TC_ConfigList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigList_2</NAME>
#define TC_IMPL_TC_ConfigList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigList_3</NAME>
#define TC_IMPL_TC_ConfigList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigList_4</NAME>
#define TC_IMPL_TC_ConfigList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigList</NAME>
#define TC_ConfigList ((CORBA_TypeCode)&TC_ConfigList_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigList__alloc</NAME>
<RETURNS>ConfigList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<TYPEDEF>
<NAME>ConfigValue</NAME>
   typedef struct {
      ConfigValueType _d;
      union {
	 CORBA_long dummy;
	 CORBA_long int_value;
	 CORBA_char *string_value;
	 CORBA_float float_value;
	 CORBA_boolean bool_value;
	 ConfigSchema schema_value;
	 ConfigList list_value;
	 BasicValueList pair_value;
      } _u;
   } ConfigValue;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValue_0</NAME>
#define TC_IMPL_TC_ConfigValue_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValue_1</NAME>
#define TC_IMPL_TC_ConfigValue_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValue_2</NAME>
#define TC_IMPL_TC_ConfigValue_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValue_3</NAME>
#define TC_IMPL_TC_ConfigValue_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValue_4</NAME>
#define TC_IMPL_TC_ConfigValue_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigValue</NAME>
#define TC_ConfigValue ((CORBA_TypeCode)&TC_ConfigValue_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigValue__alloc</NAME>
<RETURNS>ConfigValue  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigValue__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_ConfigListener</NAME>
#define ORBIT_DECL_ConfigListener 1
</MACRO>
<MACRO>
<NAME>ConfigListener__free</NAME>
#define ConfigListener__free CORBA_Object__free
</MACRO>
<TYPEDEF>
<NAME>ConfigListener</NAME>
   typedef CORBA_Object ConfigListener;
</TYPEDEF>
<VARIABLE>
<NAME>ConfigListener__classid</NAME>
   extern CORBA_unsigned_long ConfigListener__classid;
</VARIABLE>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_0</NAME>
#define TC_IMPL_TC_ConfigListener_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_1</NAME>
#define TC_IMPL_TC_ConfigListener_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_2</NAME>
#define TC_IMPL_TC_ConfigListener_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_3</NAME>
#define TC_IMPL_TC_ConfigListener_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_4</NAME>
#define TC_IMPL_TC_ConfigListener_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigListener</NAME>
#define TC_ConfigListener ((CORBA_TypeCode)&TC_ConfigListener_struct)
</MACRO>
<ENUM>
<NAME>ConfigErrorType</NAME>
   typedef enum {
      ConfigFailed,
      ConfigNoPermission,
      ConfigBadAddress,
      ConfigBadKey,
      ConfigParseError,
      ConfigCorrupt,
      ConfigTypeMismatch,
      ConfigIsDir,
      ConfigIsKey,
      ConfigOverridden,
      ConfigLockFailed
   } ConfigErrorType;
</ENUM>
<MACRO>
<NAME>TC_IMPL_TC_ConfigErrorType_0</NAME>
#define TC_IMPL_TC_ConfigErrorType_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigErrorType_1</NAME>
#define TC_IMPL_TC_ConfigErrorType_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigErrorType_2</NAME>
#define TC_IMPL_TC_ConfigErrorType_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigErrorType_3</NAME>
#define TC_IMPL_TC_ConfigErrorType_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigErrorType_4</NAME>
#define TC_IMPL_TC_ConfigErrorType_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigErrorType</NAME>
#define TC_ConfigErrorType ((CORBA_TypeCode)&TC_ConfigErrorType_struct)
</MACRO>
<MACRO>
<NAME>ex_ConfigException</NAME>
#define ex_ConfigException "IDL:ConfigException:1.0"
</MACRO>
<TYPEDEF>
<NAME>ConfigException</NAME>
   typedef struct {
      ConfigErrorType err_no;
      CORBA_char *message;
   } ConfigException;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigException_0</NAME>
#define TC_IMPL_TC_ConfigException_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigException_1</NAME>
#define TC_IMPL_TC_ConfigException_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigException_2</NAME>
#define TC_IMPL_TC_ConfigException_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigException_3</NAME>
#define TC_IMPL_TC_ConfigException_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigException_4</NAME>
#define TC_IMPL_TC_ConfigException_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigException</NAME>
#define TC_ConfigException ((CORBA_TypeCode)&TC_ConfigException_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigException__alloc</NAME>
<RETURNS>ConfigException  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigException__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_ConfigServer</NAME>
#define ORBIT_DECL_ConfigServer 1
</MACRO>
<MACRO>
<NAME>ConfigServer__free</NAME>
#define ConfigServer__free CORBA_Object__free
</MACRO>
<TYPEDEF>
<NAME>ConfigServer</NAME>
   typedef CORBA_Object ConfigServer;
</TYPEDEF>
<VARIABLE>
<NAME>ConfigServer__classid</NAME>
   extern CORBA_unsigned_long ConfigServer__classid;
</VARIABLE>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_0</NAME>
#define TC_IMPL_TC_ConfigServer_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_1</NAME>
#define TC_IMPL_TC_ConfigServer_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_2</NAME>
#define TC_IMPL_TC_ConfigServer_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_3</NAME>
#define TC_IMPL_TC_ConfigServer_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_4</NAME>
#define TC_IMPL_TC_ConfigServer_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigServer</NAME>
#define TC_ConfigServer ((CORBA_TypeCode)&TC_ConfigServer_struct)
</MACRO>
<MACRO>
<NAME>ORBIT_DECL_CORBA_sequence_CORBA_string</NAME>
#define ORBIT_DECL_CORBA_sequence_CORBA_string 1
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_0</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_0 'G'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_1</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_1 'C'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_2</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_2 'o'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_3</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_3 'n'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_4</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_4 'f'
</MACRO>
<TYPEDEF>
<NAME>CORBA_sequence_CORBA_string</NAME>
   typedef struct {
      CORBA_unsigned_long _maximum,
       _length;
      CORBA_char **_buffer;
      CORBA_boolean _release;
   } CORBA_sequence_CORBA_string;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_0</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_1</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_2</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_3</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_4</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_4 'f'
</MACRO>
<MACRO>
<NAME>TC_CORBA_sequence_CORBA_string</NAME>
#define TC_CORBA_sequence_CORBA_string ((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_string_struct)
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_string__alloc</NAME>
<RETURNS>CORBA_sequence_CORBA_string  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_string__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_string_allocbuf</NAME>
<RETURNS>CORBA_char  **</RETURNS>
CORBA_unsigned_long len
</FUNCTION>
<TYPEDEF>
<NAME>ConfigServer_KeyList</NAME>
   typedef CORBA_sequence_CORBA_string ConfigServer_KeyList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_KeyList_0</NAME>
#define TC_IMPL_TC_ConfigServer_KeyList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_KeyList_1</NAME>
#define TC_IMPL_TC_ConfigServer_KeyList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_KeyList_2</NAME>
#define TC_IMPL_TC_ConfigServer_KeyList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_KeyList_3</NAME>
#define TC_IMPL_TC_ConfigServer_KeyList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_KeyList_4</NAME>
#define TC_IMPL_TC_ConfigServer_KeyList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigServer_KeyList</NAME>
#define TC_ConfigServer_KeyList ((CORBA_TypeCode)&TC_ConfigServer_KeyList_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigServer_KeyList__alloc</NAME>
<RETURNS>ConfigServer_KeyList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_KeyList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_CORBA_sequence_ConfigValue</NAME>
#define ORBIT_DECL_CORBA_sequence_ConfigValue 1
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigValue_0</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigValue_0 'G'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigValue_1</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigValue_1 'C'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigValue_2</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigValue_2 'o'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigValue_3</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigValue_3 'n'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigValue_4</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigValue_4 'f'
</MACRO>
<TYPEDEF>
<NAME>CORBA_sequence_ConfigValue</NAME>
   typedef struct {
      CORBA_unsigned_long _maximum,
       _length;
      ConfigValue *_buffer;
      CORBA_boolean _release;
   } CORBA_sequence_ConfigValue;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigValue_0</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigValue_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigValue_1</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigValue_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigValue_2</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigValue_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigValue_3</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigValue_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigValue_4</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigValue_4 'f'
</MACRO>
<MACRO>
<NAME>TC_CORBA_sequence_ConfigValue</NAME>
#define TC_CORBA_sequence_ConfigValue ((CORBA_TypeCode)&TC_CORBA_sequence_ConfigValue_struct)
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_ConfigValue__alloc</NAME>
<RETURNS>CORBA_sequence_ConfigValue  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_ConfigValue__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_ConfigValue_allocbuf</NAME>
<RETURNS>ConfigValue  *</RETURNS>
CORBA_unsigned_long len
</FUNCTION>
<TYPEDEF>
<NAME>ConfigServer_ValueList</NAME>
   typedef CORBA_sequence_ConfigValue ConfigServer_ValueList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_ValueList_0</NAME>
#define TC_IMPL_TC_ConfigServer_ValueList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_ValueList_1</NAME>
#define TC_IMPL_TC_ConfigServer_ValueList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_ValueList_2</NAME>
#define TC_IMPL_TC_ConfigServer_ValueList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_ValueList_3</NAME>
#define TC_IMPL_TC_ConfigServer_ValueList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_ValueList_4</NAME>
#define TC_IMPL_TC_ConfigServer_ValueList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigServer_ValueList</NAME>
#define TC_ConfigServer_ValueList ((CORBA_TypeCode)&TC_ConfigServer_ValueList_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigServer_ValueList__alloc</NAME>
<RETURNS>ConfigServer_ValueList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_ValueList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_CORBA_sequence_CORBA_boolean</NAME>
#define ORBIT_DECL_CORBA_sequence_CORBA_boolean 1
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_0</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_0 'G'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_1</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_1 'C'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_2</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_2 'o'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_3</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_3 'n'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_4</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_4 'f'
</MACRO>
<TYPEDEF>
<NAME>CORBA_sequence_CORBA_boolean</NAME>
   typedef struct {
      CORBA_unsigned_long _maximum,
       _length;
      CORBA_boolean *_buffer;
      CORBA_boolean _release;
   } CORBA_sequence_CORBA_boolean;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_0</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_1</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_2</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_3</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_4</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_4 'f'
</MACRO>
<MACRO>
<NAME>TC_CORBA_sequence_CORBA_boolean</NAME>
#define TC_CORBA_sequence_CORBA_boolean ((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_boolean_struct)
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_boolean__alloc</NAME>
<RETURNS>CORBA_sequence_CORBA_boolean  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_boolean__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_boolean_allocbuf</NAME>
<RETURNS>CORBA_boolean  *</RETURNS>
CORBA_unsigned_long len
</FUNCTION>
<TYPEDEF>
<NAME>ConfigServer_IsDefaultList</NAME>
   typedef CORBA_sequence_CORBA_boolean ConfigServer_IsDefaultList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_IsDefaultList_0</NAME>
#define TC_IMPL_TC_ConfigServer_IsDefaultList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_IsDefaultList_1</NAME>
#define TC_IMPL_TC_ConfigServer_IsDefaultList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_IsDefaultList_2</NAME>
#define TC_IMPL_TC_ConfigServer_IsDefaultList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_IsDefaultList_3</NAME>
#define TC_IMPL_TC_ConfigServer_IsDefaultList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_IsDefaultList_4</NAME>
#define TC_IMPL_TC_ConfigServer_IsDefaultList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigServer_IsDefaultList</NAME>
#define TC_ConfigServer_IsDefaultList ((CORBA_TypeCode)&TC_ConfigServer_IsDefaultList_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigServer_IsDefaultList__alloc</NAME>
<RETURNS>ConfigServer_IsDefaultList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_IsDefaultList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<TYPEDEF>
<NAME>ConfigServer_Context</NAME>
   typedef CORBA_unsigned_long ConfigServer_Context;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_Context_0</NAME>
#define TC_IMPL_TC_ConfigServer_Context_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_Context_1</NAME>
#define TC_IMPL_TC_ConfigServer_Context_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_Context_2</NAME>
#define TC_IMPL_TC_ConfigServer_Context_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_Context_3</NAME>
#define TC_IMPL_TC_ConfigServer_Context_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_Context_4</NAME>
#define TC_IMPL_TC_ConfigServer_Context_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigServer_Context</NAME>
#define TC_ConfigServer_Context ((CORBA_TypeCode)&TC_ConfigServer_Context_struct)
</MACRO>
<MACRO>
<NAME>ConfigServer_invalid_context</NAME>
#define ConfigServer_invalid_context 0
</MACRO>
<MACRO>
<NAME>ConfigServer_default_context</NAME>
#define ConfigServer_default_context 1
</MACRO>
<TYPEDEF>
<NAME>POA_ConfigListener__epv</NAME>
   typedef struct {
      void *_private;
      void (*notify) (PortableServer_Servant _servant, const CORBA_unsigned_long server_context, const CORBA_unsigned_long cnxn, const CORBA_char * key, const ConfigValue * value, const CORBA_boolean is_default, CORBA_Environment * ev);
   } POA_ConfigListener__epv;
</TYPEDEF>
<TYPEDEF>
<NAME>POA_ConfigListener__vepv</NAME>
   typedef struct {
      PortableServer_ServantBase__epv *_base_epv;
      POA_ConfigListener__epv *ConfigListener_epv;
   } POA_ConfigListener__vepv;
</TYPEDEF>
<TYPEDEF>
<NAME>POA_ConfigListener</NAME>
   typedef struct {
      void *_private;
      POA_ConfigListener__vepv *vepv;
   } POA_ConfigListener;
</TYPEDEF>
<FUNCTION>
<NAME>POA_ConfigListener__init</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>POA_ConfigListener__fini</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant, CORBA_Environment * ev
</FUNCTION>
<TYPEDEF>
<NAME>POA_ConfigServer__epv</NAME>
   typedef struct {
      void *_private;
       ConfigServer_Context(*get_context) (PortableServer_Servant _servant, const CORBA_char * address, CORBA_Environment * ev);
       CORBA_unsigned_long(*add_listener) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * where, const ConfigListener who, CORBA_Environment * ev);
      void (*remove_listener) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_unsigned_long cnxn, CORBA_Environment * ev);
      ConfigValue *(*lookup) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * key, CORBA_Environment * ev);
      ConfigValue *(*lookup_with_locale) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * key, const CORBA_char * locale, const CORBA_boolean use_schema_default, CORBA_boolean * value_is_default, CORBA_Environment * ev);
      ConfigValue *(*lookup_default_value) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * key, const CORBA_char * locale, CORBA_Environment * ev);
      void (*set) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * key, const ConfigValue * value, CORBA_Environment * ev);
      void (*unset) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * key, CORBA_Environment * ev);
      void (*unset_with_locale) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * key, const CORBA_char * locale, CORBA_Environment * ev);
       CORBA_boolean(*dir_exists) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * dir, CORBA_Environment * ev);
      void (*remove_dir) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * dir, CORBA_Environment * ev);
      void (*all_entries) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * dir, const CORBA_char * locale, ConfigServer_KeyList ** keys, ConfigServer_ValueList ** values, ConfigServer_IsDefaultList ** is_defaults, CORBA_Environment * ev);
      void (*all_dirs) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * dir, ConfigServer_KeyList ** subdirs, CORBA_Environment * ev);
      void (*set_schema) (PortableServer_Servant _servant, const ConfigServer_Context ctx, const CORBA_char * key, const CORBA_char * schema_key, CORBA_Environment * ev);
      void (*sync) (PortableServer_Servant _servant, const ConfigServer_Context ctx, CORBA_Environment * ev);
       CORBA_long(*ping) (PortableServer_Servant _servant, CORBA_Environment * ev);
      void (*shutdown) (PortableServer_Servant _servant, CORBA_Environment * ev);
      void (*clear_cache) (PortableServer_Servant _servant, const ConfigServer_Context ctx, CORBA_Environment * ev);
      void (*synchronous_sync) (PortableServer_Servant _servant, const ConfigServer_Context ctx, CORBA_Environment * ev);
   } POA_ConfigServer__epv;
</TYPEDEF>
<TYPEDEF>
<NAME>POA_ConfigServer__vepv</NAME>
   typedef struct {
      PortableServer_ServantBase__epv *_base_epv;
      POA_ConfigServer__epv *ConfigServer_epv;
   } POA_ConfigServer__vepv;
</TYPEDEF>
<TYPEDEF>
<NAME>POA_ConfigServer</NAME>
   typedef struct {
      void *_private;
      POA_ConfigServer__vepv *vepv;
   } POA_ConfigServer;
</TYPEDEF>
<FUNCTION>
<NAME>POA_ConfigServer__init</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>POA_ConfigServer__fini</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigListener_notify</NAME>
<RETURNS>void  </RETURNS>
ConfigListener _obj, const CORBA_unsigned_long server_context, const CORBA_unsigned_long cnxn, const CORBA_char * key, const ConfigValue * value, const CORBA_boolean is_default, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_get_context</NAME>
<RETURNS>ConfigServer_Context  </RETURNS>
ConfigServer _obj, const CORBA_char * address, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_add_listener</NAME>
<RETURNS>CORBA_unsigned_long  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * where, const ConfigListener who, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_remove_listener</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_unsigned_long cnxn, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_lookup</NAME>
<RETURNS>ConfigValue  *</RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * key, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_lookup_with_locale</NAME>
<RETURNS>ConfigValue  *</RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * key, const CORBA_char * locale, const CORBA_boolean use_schema_default, CORBA_boolean * value_is_default, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_lookup_default_value</NAME>
<RETURNS>ConfigValue  *</RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * key, const CORBA_char * locale, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_set</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * key, const ConfigValue * value, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_unset</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * key, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_unset_with_locale</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * key, const CORBA_char * locale, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_dir_exists</NAME>
<RETURNS>CORBA_boolean  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * dir, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_remove_dir</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * dir, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_all_entries</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * dir, const CORBA_char * locale, ConfigServer_KeyList ** keys, ConfigServer_ValueList ** values, ConfigServer_IsDefaultList ** is_defaults, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_all_dirs</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * dir, ConfigServer_KeyList ** subdirs, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_set_schema</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, const CORBA_char * key, const CORBA_char * schema_key, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_sync</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_ping</NAME>
<RETURNS>CORBA_long  </RETURNS>
ConfigServer _obj, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_shutdown</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_clear_cache</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_synchronous_sync</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, const ConfigServer_Context ctx, CORBA_Environment * ev
</FUNCTION>
<STRUCT>
<NAME>GConfBackend</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfSource</NAME>
struct GConfSource {
  guint flags;
  gchar* address;
  GConfBackend* backend;
};
</STRUCT>
<ENUM>
<NAME>GConfSourceFlags</NAME>
typedef enum {
  /* These are an optimization to avoid calls to
   * the writeable/readable methods in the backend
   * vtable
   */
  GCONF_SOURCE_ALL_WRITEABLE = 1 << 0,
  GCONF_SOURCE_ALL_READABLE = 1 << 1,
  GCONF_SOURCE_NEVER_WRITEABLE = 1 << 2, 
  GCONF_SOURCE_ALL_FLAGS = ((1 << 0) | (1 << 1))
} GConfSourceFlags;
</ENUM>
<FUNCTION>
<NAME>gconf_resolve_address</NAME>
<RETURNS>GConfSource *</RETURNS>
const gchar* address,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_source_destroy</NAME>
<RETURNS>void  </RETURNS>
GConfSource* source
</FUNCTION>
<STRUCT>
<NAME>GConfSources</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfSources</NAME>
struct GConfSources {
  GList* sources;
  
};
</STRUCT>
<FUNCTION>
<NAME>gconf_sources_new_from_addresses</NAME>
<RETURNS>GConfSources *</RETURNS>
const gchar **addresses,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_new_from_source</NAME>
<RETURNS>GConfSources *</RETURNS>
GConfSource   *source
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_destroy</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_clear_cache</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_query_value</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfSources  *sources,const gchar   *key,const gchar  **locales,gboolean       use_schema_default,gboolean      *value_is_default,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_set_value</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources,const gchar   *key,GConfValue    *value,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_unset_value</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources,const gchar   *key,const gchar   *locale,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
GConfSources  *sources,const gchar   *dir,const gchar  **locales,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_all_dirs</NAME>
<RETURNS>GSList *</RETURNS>
GConfSources  *sources,const gchar   *dir,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_dir_exists</NAME>
<RETURNS>gboolean  </RETURNS>
GConfSources  *sources,const gchar   *dir,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_remove_dir</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources,const gchar   *dir,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources,const gchar   *key,const gchar   *schema_key,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_sync_all</NAME>
<RETURNS>gboolean  </RETURNS>
GConfSources  *sources,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_query_metainfo</NAME>
<RETURNS>GConfMetaInfo *</RETURNS>
GConfSources* sources,const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_query_default_value</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfSources* sources,const gchar* key,const gchar** locales,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_is_initialized</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<USER_FUNCTION>
<NAME>GConfNotifyFunc</NAME>
<RETURNS>void </RETURNS>
GConfEngine* conf, guint cnxn_id, const gchar* key, GConfValue* value, gboolean is_default, gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gconf_notify_add</NAME>
<RETURNS>guint  </RETURNS>
GConfEngine      *conf,const gchar      *namespace_section,GConfNotifyFunc   func,gpointer          user_data,GError      **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_notify_remove</NAME>
<RETURNS>void  </RETURNS>
GConfEngine      *conf,guint             cnxn
</FUNCTION>
<FUNCTION>
<NAME>gconf_get</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_without_default</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_full</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,const gchar  *locale,gboolean      use_schema_default,gboolean     *value_is_default,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_with_locale</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,const gchar  *locale,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_default_from_schema</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine  *conf,const gchar  *key,GConfValue   *value,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_unset</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine  *conf,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_associate_schema</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine  *conf,const gchar  *key,const gchar  *schema_key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
GConfEngine  *conf,const gchar  *dir,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_all_dirs</NAME>
<RETURNS>GSList *</RETURNS>
GConfEngine  *conf,const gchar  *dir,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_suggest_sync</NAME>
<RETURNS>void  </RETURNS>
GConfEngine  *conf,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_dir_exists</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine  *conf,const gchar  *dir,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_valid_key</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *key,gchar       **why_invalid
</FUNCTION>
<FUNCTION>
<NAME>gconf_key_is_below</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *above,const gchar  *below
</FUNCTION>
<FUNCTION>
<NAME>gconf_concat_key_and_dir</NAME>
<RETURNS>gchar *</RETURNS>
const gchar  *dir,const gchar  *key
</FUNCTION>
<FUNCTION>
<NAME>gconf_unique_key</NAME>
<RETURNS>gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_float</NAME>
<RETURNS>gdouble  </RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_int</NAME>
<RETURNS>gint  </RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_string</NAME>
<RETURNS>gchar *</RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_bool</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_schema</NAME>
<RETURNS>GConfSchema *</RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_list</NAME>
<RETURNS>GSList *</RETURNS>
GConfEngine     *conf,const gchar     *key,GConfValueType   list_type,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_pair</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GConfValueType   car_type,GConfValueType   cdr_type,gpointer         car_retloc,gpointer         cdr_retloc,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_float</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,gdouble          val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_int</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,gint             val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_string</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,const gchar     *val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_bool</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,gboolean         val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_schema</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GConfSchema     *val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_list</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GConfValueType   list_type,GSList          *list,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_pair</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GConfValueType   car_type,GConfValueType   cdr_type,gconstpointer    address_of_car,gconstpointer    address_of_cdr,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_init</NAME>
<RETURNS>gboolean  </RETURNS>
int argc, char **argv, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_preinit</NAME>
<RETURNS>void  </RETURNS>
gpointer app, gpointer mod_info
</FUNCTION>
<FUNCTION>
<NAME>gconf_postinit</NAME>
<RETURNS>void  </RETURNS>
gpointer app, gpointer mod_info
</FUNCTION>
<STRUCT>
<NAME>GConfEnumStringPair</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfEnumStringPair</NAME>
struct GConfEnumStringPair {
  gint enum_value;
  const gchar* str;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_string_to_enum</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEnumStringPair  lookup_table[],const gchar         *str,gint                *enum_value_retloc
</FUNCTION>
<FUNCTION>
<NAME>gconf_enum_to_string</NAME>
<RETURNS>const gchar *</RETURNS>
GConfEnumStringPair  lookup_table[],gint                 enum_value
</FUNCTION>
<FUNCTION>
<NAME>gconf_clear_cache</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_synchronous_sync</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf, GError** err
</FUNCTION>
<STRUCT>
<NAME>GConfBackendVTable</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfBackendVTable</NAME>
struct GConfBackendVTable {
  void                (* shutdown)        (GError** err);

  GConfSource*        (* resolve_address) (const gchar* address,
                                           GError** err);

  /* Thread locks. If the backend is thread-safe, then these
   * can be NULL. If per-source locks are needed, then these
   * calls should lock a mutex stored in the GConfSource.
   * If a per-backend lock is needed, then the calls can ignore
   * their source argument and lock the whole backend.
   */
  void                (* lock)            (GConfSource* source,
                                           GError** err);

  void                (* unlock)          (GConfSource* source,
                                           GError** err);

  /* Report whether a given key (and its subkeys) can be read/written.
   * Sources may not permit reading/writing from/to /foo but forbid
   * writing to /foo/bar; if a key can be read or written then its
   * subkeys may also be read/written.
   *
   * This field allows backends to be configured so that they only
   * store certain kinds of data in certain sections of the GConf
   * namespace.
   *
   * If these functions return an error, they MUST return FALSE as
   * well.
   */

  gboolean           (* readable)         (GConfSource* source,
                                           const gchar* key,
                                           GError** err);

  gboolean           (* writeable)        (GConfSource* source,
                                           const gchar* key,
                                           GError** err);
  
  /* schema_name filled if NULL or GCONF_VALUE_IGNORE_SUBSEQUENT returned.
     if schema_name is NULL, it isn't filled */
  GConfValue*         (* query_value)     (GConfSource* source, 
                                           const gchar* key,
                                           const gchar** locales,
                                           gchar** schema_name,
                                           GError** err);
  
  GConfMetaInfo*      (* query_metainfo)  (GConfSource* source,
                                           const gchar* key,
                                           GError** err);
  
  void                (* set_value)       (GConfSource* source, 
                                           const gchar* key, 
                                           GConfValue* value,
                                           GError** err);

  /* Returns list of GConfEntry */
  GSList*             (* all_entries)     (GConfSource* source,
                                           const gchar* dir,
                                           const gchar** locales,
                                           GError** err);

  /* Returns list of allocated strings, relative names */
  GSList*             (* all_subdirs)     (GConfSource* source,
                                           const gchar* dir,
                                           GError** err);

  void                (* unset_value)     (GConfSource* source,
                                           const gchar* key,
                                           const gchar* locale,
                                           GError** err);

  gboolean            (* dir_exists)      (GConfSource* source,
                                           const gchar* dir,
                                           GError** err);
        
  void                (* remove_dir)      (GConfSource* source,
                                           const gchar* dir,
                                           GError** err);
  
  void                (* set_schema)      (GConfSource* source,
                                           const gchar* key,
                                           const gchar* schema_key,
                                           GError** err);

  gboolean            (* sync_all)        (GConfSource* source,
                                           GError** err);

  void                (* destroy_source)  (GConfSource* source);

  /* This is basically used by the test suite */
  void                (* clear_cache)     (GConfSource* source);
};
</STRUCT>
<STRUCT>
<NAME>GConfBackend</NAME>
struct GConfBackend {
  const gchar* name;
  guint refcount;
  GConfBackendVTable* vtable;
  GModule* module;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_address_backend</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* address
</FUNCTION>
<FUNCTION>
<NAME>gconf_address_resource</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* address
</FUNCTION>
<FUNCTION>
<NAME>gconf_address_flags</NAME>
<RETURNS>gchar **</RETURNS>
const gchar* address
</FUNCTION>
<FUNCTION>
<NAME>gconf_backend_file</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* address
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_backend</NAME>
<RETURNS>GConfBackend *</RETURNS>
const gchar* address, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_backend_ref</NAME>
<RETURNS>void  </RETURNS>
GConfBackend* backend
</FUNCTION>
<FUNCTION>
<NAME>gconf_backend_unref</NAME>
<RETURNS>void  </RETURNS>
GConfBackend* backend
</FUNCTION>
<FUNCTION>
<NAME>gconf_backend_resolve_address</NAME>
<RETURNS>GConfSource *</RETURNS>
GConfBackend* backend,const gchar* address,GError** err
</FUNCTION>
<STRUCT>
<NAME>GConfChangeSet</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GConfChangeSetForeachFunc</NAME>
<RETURNS>void </RETURNS>
GConfChangeSet* cs,
                                            const gchar* key,
                                            GConfValue* value,
                                            gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gconf_commit_change_set</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine* conf,GConfChangeSet* cs,gboolean remove_committed,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_create_reverse_change_set</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfEngine* conf,GConfChangeSet* cs,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_create_change_set_from_currentv</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfEngine* conf,const gchar** keys,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_create_change_set_from_current</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfEngine* conf,GError** err,const gchar* first_key,...
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_new</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_ref</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_unref</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_clear</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_size</NAME>
<RETURNS>guint  </RETURNS>
GConfChangeSet* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_remove</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs,const gchar* key
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_foreach</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs,GConfChangeSetForeachFunc func,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_check_value</NAME>
<RETURNS>gboolean  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValue** value_retloc
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_unset</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_float</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,gdouble val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_int</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,gint val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_string</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,const gchar* val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_bool</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,gboolean val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfSchema* val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_list</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValueType list_type,GSList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_pair</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValueType car_type, GConfValueType cdr_type,gconstpointer address_of_car,gconstpointer address_of_cdr
</FUNCTION>
<STRUCT>
<NAME>GConfListeners</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfListeners</NAME>
struct GConfListeners {
  gpointer dummy;
};
</STRUCT>
<USER_FUNCTION>
<NAME>GConfListenersCallback</NAME>
<RETURNS>void </RETURNS>
GConfListeners* listeners,
                                       const gchar* all_above_key,
                                       guint cnxn_id,
                                       gpointer listener_data,
                                       gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_new</NAME>
<RETURNS>GConfListeners *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_destroy</NAME>
<RETURNS>void  </RETURNS>
GConfListeners* listeners
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_add</NAME>
<RETURNS>guint  </RETURNS>
GConfListeners* listeners,const gchar* listen_point,gpointer listener_data,GFreeFunc destroy_notify
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_remove</NAME>
<RETURNS>void  </RETURNS>
GConfListeners* listeners,guint cnxn_id
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_notify</NAME>
<RETURNS>void  </RETURNS>
GConfListeners* listeners,const gchar* all_above,GConfListenersCallback callback,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_count</NAME>
<RETURNS>guint  </RETURNS>
GConfListeners* listeners
</FUNCTION>
<STRUCT>
<NAME>GConfSchema</NAME>
struct GConfSchema {
  GConfValueType type; /* Type of the described entry */
  gchar* locale;       /* Schema locale */
  gchar* owner;        /* Name of creating application */
  gchar* short_desc;   /* 40 char or less description, no newlines */
  gchar* long_desc;    /* could be a paragraph or so */
  GConfValue* default_value; /* Default value of the key */
};
</STRUCT>
<FUNCTION>
<NAME>gconf_schema_new</NAME>
<RETURNS>GConfSchema *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_destroy</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_copy</NAME>
<RETURNS>GConfSchema *</RETURNS>
GConfSchema* sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_type</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc, GConfValueType type
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_locale</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc, const gchar* locale
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_short_desc</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc, const gchar* desc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_long_desc</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc, const gchar* desc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_owner</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc, const gchar* owner
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_default_value</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc, GConfValue* val
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_default_value_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfSchema* sc, GConfValue* val
</FUNCTION>
<MACRO>
<NAME>gconf_schema_type</NAME>
#define       gconf_schema_type(x) (x->type)
</MACRO>
<MACRO>
<NAME>gconf_schema_locale</NAME>
#define       gconf_schema_locale(x)     ((const gchar*)(x)->locale)
</MACRO>
<MACRO>
<NAME>gconf_schema_short_desc</NAME>
#define       gconf_schema_short_desc(x) ((const gchar*)(x)->short_desc)
</MACRO>
<MACRO>
<NAME>gconf_schema_long_desc</NAME>
#define       gconf_schema_long_desc(x)  ((const gchar*)(x)->long_desc)
</MACRO>
<MACRO>
<NAME>gconf_schema_owner</NAME>
#define       gconf_schema_owner(x)      ((const gchar*)(x)->owner)
</MACRO>
<MACRO>
<NAME>gconf_schema_default_value</NAME>
#define       gconf_schema_default_value(x) ((x)->default_value)
</MACRO>
<ENUM>
<NAME>GConfValueType</NAME>
typedef enum {
  GCONF_VALUE_INVALID,
  GCONF_VALUE_STRING,
  GCONF_VALUE_INT,
  GCONF_VALUE_FLOAT,
  GCONF_VALUE_BOOL,
  GCONF_VALUE_SCHEMA,

  /* unfortunately these aren't really types; we want list_of_string,
     list_of_int, etc.  but it's just too complicated to implement.
     instead we'll complain in various places if you do something
     moronic like mix types in a list or treat pair<string,int> and
     pair<float,bool> as the same type. */
  GCONF_VALUE_LIST,
  GCONF_VALUE_PAIR
  
} GConfValueType;
</ENUM>
<MACRO>
<NAME>GCONF_VALUE_TYPE_VALID</NAME>
#define GCONF_VALUE_TYPE_VALID(x) (((x) > GCONF_VALUE_INVALID) && ((x) <= GCONF_VALUE_PAIR))
</MACRO>
<MACRO>
<NAME>GCONF_INTERNAL_VALUE_TYPE_VALID</NAME>
#define GCONF_INTERNAL_VALUE_TYPE_VALID(x) (((x) > GCONF_VALUE_INVALID) && ((x) <= GCONF_VALUE_PAIR))
</MACRO>
<STRUCT>
<NAME>GConfSchema</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfValue</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfValue</NAME>
struct GConfValue {
  GConfValueType type;
  union {
    gchar* string_data;
    gint int_data;
    gboolean bool_data;
    gdouble float_data;
    GConfSchema* schema_data;
    struct {
      GConfValueType type;
      GSList* list;
    } list_data;
    struct {
      GConfValue* car;
      GConfValue* cdr;
    } pair_data;
  } d;
};
</STRUCT>
<MACRO>
<NAME>gconf_value_string</NAME>
#define gconf_value_string(x)    ((const gchar*)((x)->d.string_data))
</MACRO>
<MACRO>
<NAME>gconf_value_int</NAME>
#define gconf_value_int(x)       ((x)->d.int_data)
</MACRO>
<MACRO>
<NAME>gconf_value_float</NAME>
#define gconf_value_float(x)     ((x)->d.float_data)
</MACRO>
<MACRO>
<NAME>gconf_value_list_type</NAME>
#define gconf_value_list_type(x) ((x)->d.list_data.type)
</MACRO>
<MACRO>
<NAME>gconf_value_list</NAME>
#define gconf_value_list(x)      ((x)->d.list_data.list)
</MACRO>
<MACRO>
<NAME>gconf_value_car</NAME>
#define gconf_value_car(x)       ((x)->d.pair_data.car)
</MACRO>
<MACRO>
<NAME>gconf_value_cdr</NAME>
#define gconf_value_cdr(x)       ((x)->d.pair_data.cdr)
</MACRO>
<MACRO>
<NAME>gconf_value_bool</NAME>
#define gconf_value_bool(x)      ((x)->d.bool_data)
</MACRO>
<MACRO>
<NAME>gconf_value_schema</NAME>
#define gconf_value_schema(x)    ((x)->d.schema_data)
</MACRO>
<FUNCTION>
<NAME>gconf_value_new</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType type
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_copy</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValue* src
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_destroy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_int</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,gint the_int
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_string</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,const gchar* the_str
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_float</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,gdouble the_float
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_bool</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,gboolean the_bool
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfSchema* sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_schema_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfSchema* sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_car</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValue* car
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_car_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValue* car
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_cdr</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValue* cdr
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_cdr_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValue* cdr
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_list_type</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValueType type
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_list_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GSList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_list</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GSList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_to_string</NAME>
<RETURNS>gchar *</RETURNS>
GConfValue* value
</FUNCTION>
<STRUCT>
<NAME>GConfMetaInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfMetaInfo</NAME>
struct GConfMetaInfo {
  gchar* schema;
  gchar* mod_user; /* user owning the daemon that made the last modification */
  GTime  mod_time; /* time of the modification */
};
</STRUCT>
<MACRO>
<NAME>gconf_meta_info_schema</NAME>
#define gconf_meta_info_schema(x)    ((const gchar*)(x)->schema)
</MACRO>
<MACRO>
<NAME>gconf_meta_info_mod_user</NAME>
#define gconf_meta_info_mod_user(x)  ((x)->mod_user)
</MACRO>
<MACRO>
<NAME>gconf_meta_info_mod_time</NAME>
#define gconf_meta_info_mod_time(x)  ((x)->mod_time)
</MACRO>
<FUNCTION>
<NAME>gconf_meta_info_new</NAME>
<RETURNS>GConfMetaInfo *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_meta_info_destroy</NAME>
<RETURNS>void  </RETURNS>
GConfMetaInfo* gcmi
</FUNCTION>
<FUNCTION>
<NAME>gconf_meta_info_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfMetaInfo* gcmi,const gchar* schema_name
</FUNCTION>
<FUNCTION>
<NAME>gconf_meta_info_set_mod_user</NAME>
<RETURNS>void  </RETURNS>
GConfMetaInfo* gcmi,const gchar* mod_user
</FUNCTION>
<FUNCTION>
<NAME>gconf_meta_info_set_mod_time</NAME>
<RETURNS>void  </RETURNS>
GConfMetaInfo* gcmi,GTime mod_time
</FUNCTION>
<STRUCT>
<NAME>GConfEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfEntry</NAME>
struct GConfEntry {
  gchar* key;
  GConfValue* value;
  gchar* schema_name;
  gboolean is_default;
};
</STRUCT>
<MACRO>
<NAME>gconf_entry_key</NAME>
#define     gconf_entry_key(x)      ((const gchar*)(x)->key)
</MACRO>
<MACRO>
<NAME>gconf_entry_value</NAME>
#define     gconf_entry_value(x)    ((x)->value)
</MACRO>
<MACRO>
<NAME>gconf_entry_schema_name</NAME>
#define     gconf_entry_schema_name(x) ((x)->schema_name)
</MACRO>
<MACRO>
<NAME>gconf_entry_is_default</NAME>
#define     gconf_entry_is_default(x)  ((x)->is_default)
</MACRO>
<FUNCTION>
<NAME>gconf_entry_new_nocopy</NAME>
<RETURNS>GConfEntry *</RETURNS>
gchar       *key,GConfValue  *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_destroy</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_steal_value</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEntry  *entry
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_set_value_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry,GConfValue  *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_set_schema_name</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry,const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_set_is_default</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry,gboolean     is_default
</FUNCTION>
<ENUM>
<NAME>GConfError</NAME>
typedef enum {
  GCONF_ERROR_SUCCESS = 0,
  GCONF_ERROR_FAILED = 1,        /* Something didn't work, don't know why, probably unrecoverable
                                    so there's no point having a more specific errno */

  GCONF_ERROR_NO_SERVER = 2,     /* Server can't be launched/contacted */
  GCONF_ERROR_NO_PERMISSION = 3, /* don't have permission for that */
  GCONF_ERROR_BAD_ADDRESS = 4,   /* Address couldn't be resolved */
  GCONF_ERROR_BAD_KEY = 5,       /* directory or key isn't valid (contains bad
                                    characters, or malformed slash arrangement) */
  GCONF_ERROR_PARSE_ERROR = 6,   /* Syntax error when parsing */
  GCONF_ERROR_CORRUPT = 7,       /* Fatal error parsing/loading information inside the backend */
  GCONF_ERROR_TYPE_MISMATCH = 8, /* Type requested doesn't match type found */
  GCONF_ERROR_IS_DIR = 9,        /* Requested key operation on a dir */
  GCONF_ERROR_IS_KEY = 10,       /* Requested dir operation on a key */
  GCONF_ERROR_OVERRIDDEN = 11,   /* Read-only source at front of path has set the value */
  GCONF_ERROR_OAF_ERROR = 12,    /* liboaf error */
  GCONF_ERROR_LOCAL_ENGINE = 13, /* Tried to use remote operations on a local engine */
  GCONF_ERROR_LOCK_FAILED = 14   /* Failed to get a lockfile */
} GConfError;
</ENUM>
<STRUCT>
<NAME>GError</NAME>
</STRUCT>
<STRUCT>
<NAME>GError</NAME>
struct GError {
  const gchar* str; /* combination of strerror of the num and additional
                       details; a complete error message. */
  GConfError num;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_error_new</NAME>
<RETURNS>GError *</RETURNS>
GConfError en, const gchar* format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_error_copy</NAME>
<RETURNS>GError *</RETURNS>
GError* err
</FUNCTION>
<FUNCTION>
<NAME>g_error_free</NAME>
<RETURNS>void  </RETURNS>
GError* err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_error</NAME>
<RETURNS>void  </RETURNS>
GError** err, GConfError en, const gchar* format, ...
</FUNCTION>
<FUNCTION>
<NAME>g_clear_error</NAME>
<RETURNS>void  </RETURNS>
GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_compose_errors</NAME>
<RETURNS>GError *</RETURNS>
GError* err1, GError* err2
</FUNCTION>
<FUNCTION>
<NAME>gconf_strerror</NAME>
<RETURNS>const gchar *</RETURNS>
GConfError en
</FUNCTION>
<STRUCT>
<NAME>GConfEngine</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfEngine</NAME>
struct GConfEngine {
  gpointer dummy;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_engine_new</NAME>
<RETURNS>GConfEngine *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_new_from_address</NAME>
<RETURNS>GConfEngine *</RETURNS>
const gchar* address, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_unref</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_ref</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_new_local</NAME>
<RETURNS>GConfEngine *</RETURNS>
const gchar* address, GError** err
</FUNCTION>
<STRUCT>
<NAME>Cache</NAME>
</STRUCT>
<FUNCTION>
<NAME>cache_new</NAME>
<RETURNS>Cache *</RETURNS>
const gchar  *root_dir,guint dir_mode,guint file_mode
</FUNCTION>
<FUNCTION>
<NAME>cache_destroy</NAME>
<RETURNS>void  </RETURNS>
Cache        *cache
</FUNCTION>
<FUNCTION>
<NAME>cache_sync</NAME>
<RETURNS>gboolean  </RETURNS>
Cache        *cache,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>cache_clean</NAME>
<RETURNS>void  </RETURNS>
Cache        *cache,GTime         older_than
</FUNCTION>
<FUNCTION>
<NAME>cache_delete_dir</NAME>
<RETURNS>void  </RETURNS>
Cache        *cache,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>cache_lookup</NAME>
<RETURNS>Dir *</RETURNS>
Cache        *cache,const gchar  *key,gboolean create_if_missing,GError  **err
</FUNCTION>
<STRUCT>
<NAME>Dir</NAME>
</STRUCT>
<FUNCTION>
<NAME>dir_new</NAME>
<RETURNS>Dir *</RETURNS>
const gchar  *keyname,const gchar  *xml_root_dir,guint dir_mode,guint file_mode
</FUNCTION>
<FUNCTION>
<NAME>dir_load</NAME>
<RETURNS>Dir *</RETURNS>
const gchar  *key,const gchar  *xml_root_dir,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_destroy</NAME>
<RETURNS>void  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_clear_cache</NAME>
<RETURNS>void  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_ensure_exists</NAME>
<RETURNS>gboolean  </RETURNS>
Dir          *d,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_sync</NAME>
<RETURNS>gboolean  </RETURNS>
Dir          *d,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_get_name</NAME>
<RETURNS>const gchar *</RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_set_value</NAME>
<RETURNS>void  </RETURNS>
Dir          *d,const gchar  *relative_key,GConfValue   *value,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_get_value</NAME>
<RETURNS>GConfValue *</RETURNS>
Dir          *d,const gchar  *relative_key,const gchar **locales,gchar       **schema_name,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_get_metainfo</NAME>
<RETURNS>GConfMetaInfo *</RETURNS>
Dir          *d,const gchar  *relative_key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_unset_value</NAME>
<RETURNS>void  </RETURNS>
Dir          *d,const gchar  *relative_key,const gchar  *locale,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
Dir          *d,const gchar **locales,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_all_subdirs</NAME>
<RETURNS>GSList *</RETURNS>
Dir          *d,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_set_schema</NAME>
<RETURNS>void  </RETURNS>
Dir          *d,const gchar  *relative_key,const gchar  *schema_key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_get_last_access</NAME>
<RETURNS>GTime  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_sync_pending</NAME>
<RETURNS>gboolean  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_mark_deleted</NAME>
<RETURNS>void  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_is_deleted</NAME>
<RETURNS>gboolean  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>mode_t_to_mode</NAME>
<RETURNS>guint  </RETURNS>
mode_t orig
</FUNCTION>
<STRUCT>
<NAME>Entry</NAME>
</STRUCT>
<FUNCTION>
<NAME>entry_new</NAME>
<RETURNS>Entry *</RETURNS>
const gchar  *relative_name
</FUNCTION>
<FUNCTION>
<NAME>entry_destroy</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_get_name</NAME>
<RETURNS>const gchar *</RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_set_node</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry,xmlNodePtr    node
</FUNCTION>
<FUNCTION>
<NAME>entry_get_node</NAME>
<RETURNS>xmlNodePtr  </RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_fill_from_node</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_sync_to_node</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_get_value</NAME>
<RETURNS>GConfValue *</RETURNS>
Entry        *entry,const gchar **locales,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>entry_set_value</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry,GConfValue   *value
</FUNCTION>
<FUNCTION>
<NAME>entry_unset_value</NAME>
<RETURNS>gboolean  </RETURNS>
Entry        *entry,const gchar  *locale
</FUNCTION>
<FUNCTION>
<NAME>entry_get_metainfo</NAME>
<RETURNS>GConfMetaInfo *</RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_set_mod_time</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry,GTime         mod_time
</FUNCTION>
<FUNCTION>
<NAME>entry_set_mod_user</NAME>
<RETURNS>void  </RETURNS>
Entry        *e,const gchar  *user
</FUNCTION>
<FUNCTION>
<NAME>entry_get_schema_name</NAME>
<RETURNS>const gchar *</RETURNS>
Entry        *e
</FUNCTION>
<FUNCTION>
<NAME>entry_set_schema_name</NAME>
<RETURNS>void  </RETURNS>
Entry        *e,const gchar  *name
</FUNCTION>
<FUNCTION>
<NAME>my_xmlSetProp</NAME>
<RETURNS>void  </RETURNS>
xmlNodePtr node,const gchar* name,const gchar* str
</FUNCTION>
<FUNCTION>
<NAME>my_xmlGetProp</NAME>
<RETURNS>char *</RETURNS>
xmlNodePtr node,const gchar* name
</FUNCTION>
<ENUM>
<NAME>GConfClientPreloadType</NAME>
typedef enum {
  GCONF_CLIENT_PRELOAD_NONE,     /* don't preload anything */
  GCONF_CLIENT_PRELOAD_ONELEVEL, /* load entries directly under the directory. */
  GCONF_CLIENT_PRELOAD_RECURSIVE /* recurse the directory tree; possibly quite expensive! */
} GConfClientPreloadType;
</ENUM>
<ENUM>
<NAME>GConfClientErrorHandlingMode</NAME>
typedef enum {
  GCONF_CLIENT_HANDLE_NONE,
  GCONF_CLIENT_HANDLE_UNRETURNED,
  GCONF_CLIENT_HANDLE_ALL
} GConfClientErrorHandlingMode;
</ENUM>
<STRUCT>
<NAME>GConfClient</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfClientClass</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GConfClientNotifyFunc</NAME>
<RETURNS>void </RETURNS>
GConfClient* client, guint cnxn_id, const gchar* key, GConfValue* value, gboolean is_default, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GConfClientParentWindowFunc</NAME>
<RETURNS>GtkWidget *</RETURNS>
GConfClient* client, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GConfClientErrorHandlerFunc</NAME>
<RETURNS>void </RETURNS>
GConfClient* client, GConfClientParentWindowFunc parent_func, gpointer parent_user_data, GError* error
</USER_FUNCTION>
<MACRO>
<NAME>GCONF_TYPE_CLIENT</NAME>
#define GCONF_TYPE_CLIENT                  (gconf_client_get_type ())
</MACRO>
<MACRO>
<NAME>GCONF_CLIENT</NAME>
#define GCONF_CLIENT(obj)                  (GTK_CHECK_CAST ((obj), GCONF_TYPE_CLIENT, GConfClient))
</MACRO>
<MACRO>
<NAME>GCONF_CLIENT_CLASS</NAME>
#define GCONF_CLIENT_CLASS(klass)          (CONF_CHECK_CLASS_CAST ((klass), GCONF_TYPE_CLIENT, GConfClientClass))
</MACRO>
<MACRO>
<NAME>GCONF_IS_CLIENT</NAME>
#define GCONF_IS_CLIENT(obj)               (GTK_CHECK_TYPE ((obj), GCONF_TYPE_CLIENT))
</MACRO>
<MACRO>
<NAME>GCONF_IS_CLIENT_CLASS</NAME>
#define GCONF_IS_CLIENT_CLASS(klass)       (CONF_CHECK_CLASS_TYPE ((klass), GCONF_TYPE_CLIENT))
</MACRO>
<STRUCT>
<NAME>GConfClient</NAME>
struct GConfClient
{
  GtkObject object;

  /*< private >*/

  GConfEngine* engine;
  GConfClientErrorHandlingMode error_mode;
  GConfClientParentWindowFunc parent_func;
  gpointer parent_user_data;
  GHashTable* dir_hash;
  GHashTable* cache_hash;
  GConfListeners* listeners;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_client_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_new</NAME>
<RETURNS>GConfClient *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_new_with_engine</NAME>
<RETURNS>GConfClient *</RETURNS>
GConfEngine* engine
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_add_dir</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* dir,GConfClientPreloadType preload,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_remove_dir</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* dir
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_notify_add</NAME>
<RETURNS>guint  </RETURNS>
GConfClient* client,const gchar* namespace_section,GConfClientNotifyFunc func,gpointer user_data,GFreeFunc destroy_notify,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_notify_remove</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,guint cnxn
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_error_handling</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,GConfClientErrorHandlingMode mode,GConfClientParentWindowFunc func,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_global_default_error_handler</NAME>
<RETURNS>void  </RETURNS>
GConfClientErrorHandlerFunc func
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_clear_cache</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_preload</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* dirname,GConfClientPreloadType type,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* key,GConfValue* val,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfClient* client,const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_without_default</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfClient* client,const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_full</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfClient* client,const gchar* key, const gchar* locale,gboolean use_schema_default,gboolean* value_is_default,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_default_from_schema</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfClient* client,const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_unset</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client,const gchar* key, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
GConfClient* client,const gchar* dir, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_all_dirs</NAME>
<RETURNS>GSList *</RETURNS>
GConfClient* client,const gchar* dir, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_suggest_sync</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_dir_exists</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client,const gchar* dir, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_float</NAME>
<RETURNS>gdouble  </RETURNS>
GConfClient* client, const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_int</NAME>
<RETURNS>gint  </RETURNS>
GConfClient* client, const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_string</NAME>
<RETURNS>gchar *</RETURNS>
GConfClient* client, const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_bool</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_schema</NAME>
<RETURNS>GConfSchema *</RETURNS>
GConfClient* client,const gchar* key, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_list</NAME>
<RETURNS>GSList *</RETURNS>
GConfClient* client, const gchar* key,GConfValueType list_type, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_pair</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GConfValueType car_type, GConfValueType cdr_type,gpointer car_retloc, gpointer cdr_retloc,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_float</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,gdouble val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_int</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,gint val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_string</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,const gchar* val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_bool</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,gboolean val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_schema</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GConfSchema* val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_list</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GConfValueType list_type,GSList* list,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_pair</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GConfValueType car_type, GConfValueType cdr_type,gconstpointer address_of_car,gconstpointer address_of_cdr,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_error</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client, GError* error
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_unreturned_error</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client, GError* error
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_value_changed</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* key,GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_commit_change_set</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client,GConfChangeSet* cs,gboolean remove_committed,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_create_reverse_change_set</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfClient* client,GConfChangeSet* cs,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_create_change_set_from_currentv</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfClient* client,const gchar** keys,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_create_change_set_from_current</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfClient* client,GError** err,const gchar* first_key,...
</FUNCTION>
<MACRO>
<NAME>MO_REVISION_NUMBER</NAME>
#define MO_REVISION_NUMBER 0
</MACRO>
<MACRO>
<NAME>UINT_MAX_32_BITS</NAME>
# define UINT_MAX_32_BITS 4294967295U
</MACRO>
<MACRO>
<NAME>UINT_MAX_32_BITS</NAME>
# define UINT_MAX_32_BITS 0xFFFFFFFF
</MACRO>
<MACRO>
<NAME>UINT_MAX</NAME>
# define UINT_MAX UINT_MAX_32_BITS
</MACRO>
<TYPEDEF>
<NAME>nls_uint32</NAME>
typedef unsigned nls_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>nls_uint32</NAME>
typedef unsigned short nls_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>nls_uint32</NAME>
typedef unsigned long nls_uint32;
</TYPEDEF>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) args
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) ()
</MACRO>
<MACRO>
<NAME>internal_function</NAME>
# define internal_function
</MACRO>
<MACRO>
<NAME>W</NAME>
# define W(flag, data) ((flag) ? SWAP (data) : (data))
</MACRO>
<MACRO>
<NAME>SWAP</NAME>
# define SWAP(i) bswap_32 (i)
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(Args) Args
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(Args) ()
</MACRO>
<MACRO>
<NAME>HASHWORDBITS</NAME>
#define HASHWORDBITS 32
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) args
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) ()
</MACRO>
<MACRO>
<NAME>NULL</NAME>
#  define NULL ((void *) 0)
</MACRO>
<MACRO>
<NAME>NULL</NAME>
#  define NULL (0)
</MACRO>
<MACRO>
<NAME>LC_MESSAGES</NAME>
# define LC_MESSAGES (-1)
</MACRO>
<STRUCT>
<NAME>msg_ent</NAME>
struct msg_ent
{
  const char *_msg;
  int _msg_number;
};
</STRUCT>
<MACRO>
<NAME>gettext_noop</NAME>
#define gettext_noop(Str) (Str)
</MACRO>
<MACRO>
<NAME>gettext</NAME>
#  define gettext(Msgid)						      \
     dgettext (NULL, Msgid)
</MACRO>
<MACRO>
<NAME>dgettext</NAME>
#  define dgettext(Domainname, Msgid)					      \
     dcgettext (Domainname, Msgid, LC_MESSAGES)
</MACRO>
<MACRO>
<NAME>dcgettext</NAME>
#   define dcgettext(Domainname, Msgid, Category)			      \
  (__extension__							      \
   ({									      \
     char *__result;							      \
     if (__builtin_constant_p (Msgid))					      \
       {								      \
	 static char *__translation__;					      \
	 static int __catalog_counter__;				      \
	 if (! __translation__ || __catalog_counter__ != _nl_msg_cat_cntr)    \
	   {								      \
	     __translation__ =						      \
	       dcgettext__ (Domainname, Msgid, Category);		      \
	     __catalog_counter__ = _nl_msg_cat_cntr;			      \
	   }								      \
	 __result = __translation__;					      \
       }								      \
     else								      \
       __result = dcgettext__ (Domainname, Msgid, Category);		      \
     __result;								      \
    }))
</MACRO>
<MACRO>
<NAME>gettext</NAME>
# define gettext(Msgid) (Msgid)
</MACRO>
<MACRO>
<NAME>dgettext</NAME>
# define dgettext(Domainname, Msgid) (Msgid)
</MACRO>
<MACRO>
<NAME>dcgettext</NAME>
# define dcgettext(Domainname, Msgid, Category) (Msgid)
</MACRO>
<MACRO>
<NAME>textdomain</NAME>
# define textdomain(Domainname) ((char *) Domainname)
</MACRO>
<MACRO>
<NAME>bindtextdomain</NAME>
# define bindtextdomain(Domainname, Dirname) ((char *) Dirname)
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) args
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) ()
</MACRO>
<MACRO>
<NAME>CEN_REVISION</NAME>
#define CEN_REVISION		1
</MACRO>
<MACRO>
<NAME>CEN_SPONSOR</NAME>
#define CEN_SPONSOR		2
</MACRO>
<MACRO>
<NAME>CEN_SPECIAL</NAME>
#define CEN_SPECIAL		4
</MACRO>
<MACRO>
<NAME>XPG_NORM_CODESET</NAME>
#define XPG_NORM_CODESET	8
</MACRO>
<MACRO>
<NAME>XPG_CODESET</NAME>
#define XPG_CODESET		16
</MACRO>
<MACRO>
<NAME>TERRITORY</NAME>
#define TERRITORY		32
</MACRO>
<MACRO>
<NAME>CEN_AUDIENCE</NAME>
#define CEN_AUDIENCE		64
</MACRO>
<MACRO>
<NAME>XPG_MODIFIER</NAME>
#define XPG_MODIFIER		128
</MACRO>
<MACRO>
<NAME>CEN_SPECIFIC</NAME>
#define CEN_SPECIFIC	(CEN_REVISION|CEN_SPONSOR|CEN_SPECIAL|CEN_AUDIENCE)
</MACRO>
<MACRO>
<NAME>XPG_SPECIFIC</NAME>
#define XPG_SPECIFIC	(XPG_CODESET|XPG_NORM_CODESET|XPG_MODIFIER)
</MACRO>
<FUNCTION>
<NAME>PARAMS</NAME>
<RETURNS>_nl_make_l10nflist  </RETURNS>
(struct loaded_l10nfile **l10nfile_list,const char *dirlist, size_t dirlist_len, int mask,const char *language, const char *territory,const char *codeset,const char *normalized_codeset,const char *modifier, const char *special,const char *sponsor, const char *revision,const char *filename, int do_allocate)
</FUNCTION>
